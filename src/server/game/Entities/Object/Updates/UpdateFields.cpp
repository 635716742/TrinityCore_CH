/*
 * This file is part of the TrinityCore Project. See AUTHORS file for Copyright information
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include "UpdateFields.h"
#include "AreaTrigger.h"
#include "ByteBuffer.h"
#include "Corpse.h"
#include "DynamicObject.h"
#include "Player.h"
#include "ViewerDependentValues.h"

// This file is automatically generated, DO NOT EDIT

#if TRINITY_COMPILER == TRINITY_COMPILER_GNU
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#else
#pragma warning(push)
#pragma warning(disable: 4100)
#endif

namespace UF
{
void ObjectData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Object const* owner, Player const* receiver) const
{
    data << int32(ViewerDependentValue<EntryIDTag>::GetValue(this, owner, receiver));
    data << uint32(ViewerDependentValue<DynamicFlagsTag>::GetValue(this, owner, receiver));
    data << float(Scale);
}

void ObjectData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Object const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void ObjectData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, Object const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlock(0), 4);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << int32(ViewerDependentValue<EntryIDTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[2])
        {
            data << uint32(ViewerDependentValue<DynamicFlagsTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[3])
        {
            data << float(Scale);
        }
    }
}

void ObjectData::ClearChangesMask()
{
    Base::ClearChangesMask(EntryID);
    Base::ClearChangesMask(DynamicFlags);
    Base::ClearChangesMask(Scale);
    _changesMask.ResetAll();
}

void ItemEnchantment::WriteCreate(ByteBuffer& data, Item const* owner, Player const* receiver) const
{
    data << int32(ID);
    data << uint32(Duration);
    data << int16(Charges);
    data << uint8(Unk254);
    data << uint8(Unk254_2);
}

void ItemEnchantment::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Item const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 6);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << int32(ID);
        }
        if (changesMask[2])
        {
            data << uint32(Duration);
        }
        if (changesMask[3])
        {
            data << int16(Charges);
        }
        if (changesMask[4])
        {
            data << uint8(Unk254);
        }
        if (changesMask[5])
        {
            data << uint8(Unk254_2);
        }
    }
}

void ItemEnchantment::ClearChangesMask()
{
    Base::ClearChangesMask(ID);
    Base::ClearChangesMask(Duration);
    Base::ClearChangesMask(Charges);
    Base::ClearChangesMask(Unk254);
    Base::ClearChangesMask(Unk254_2);
    _changesMask.ResetAll();
}

void ItemMod::WriteCreate(ByteBuffer& data, Item const* owner, Player const* receiver) const
{
    data << int32(Value);
    data << uint8(Type);
}

void ItemMod::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Item const* owner, Player const* receiver) const
{
    data << int32(Value);
    data << uint8(Type);
}

bool ItemMod::operator==(ItemMod const& right) const
{
    return Value == right.Value
        && Type == right.Type;
}

void ItemModList::WriteCreate(ByteBuffer& data, Item const* owner, Player const* receiver) const
{
    data.WriteBits(Values.size(), 6);
    for (std::size_t i = 0; i < Values.size(); ++i)
    {
        Values[i].WriteCreate(data, owner, receiver);
    }
    data.FlushBits();
}

void ItemModList::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Item const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 1);

    if (changesMask[0])
    {
        if (changesMask[0])
        {
            if (!ignoreChangesMask)
                Values.WriteUpdateMask(data, 6);
            else
                WriteCompleteDynamicFieldUpdateMask(Values.size(), data, 6);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[0])
        {
            for (std::size_t i = 0; i < Values.size(); ++i)
            {
                if (Values.HasChanged(i) || ignoreChangesMask)
                {
                    Values[i].WriteUpdate(data, ignoreChangesMask, owner, receiver);
                }
            }
        }
    }
    data.FlushBits();
}

void ItemModList::ClearChangesMask()
{
    Base::ClearChangesMask(Values);
    _changesMask.ResetAll();
}

void ArtifactPower::WriteCreate(ByteBuffer& data, Item const* owner, Player const* receiver) const
{
    data << int16(ArtifactPowerID);
    data << uint8(PurchasedRank);
    data << uint8(CurrentRankWithBonus);
}

void ArtifactPower::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Item const* owner, Player const* receiver) const
{
    data << int16(ArtifactPowerID);
    data << uint8(PurchasedRank);
    data << uint8(CurrentRankWithBonus);
}

bool ArtifactPower::operator==(ArtifactPower const& right) const
{
    return ArtifactPowerID == right.ArtifactPowerID
        && PurchasedRank == right.PurchasedRank
        && CurrentRankWithBonus == right.CurrentRankWithBonus;
}

void SocketedGem::WriteCreate(ByteBuffer& data, Item const* owner, Player const* receiver) const
{
    data << int32(ItemID);
    for (std::size_t i = 0; i < 16; ++i)
    {
        data << uint16(BonusListIDs[i]);
    }
    data << uint8(Context);
}

void SocketedGem::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Item const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlocksMask(0), 1);
    if (changesMask.GetBlock(0))
        data.WriteBits(changesMask.GetBlock(0), 32);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << int32(ItemID);
        }
        if (changesMask[2])
        {
            data << uint8(Context);
        }
    }
    if (changesMask[3])
    {
        for (std::size_t i = 0; i < 16; ++i)
        {
            if (changesMask[4 + i])
            {
                data << uint16(BonusListIDs[i]);
            }
        }
    }
}

void SocketedGem::ClearChangesMask()
{
    Base::ClearChangesMask(ItemID);
    Base::ClearChangesMask(Context);
    Base::ClearChangesMask(BonusListIDs);
    _changesMask.ResetAll();
}

void ItemData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Item const* owner, Player const* receiver) const
{
    data << uint32(BonusListIDs->size());
    for (std::size_t i = 0; i < BonusListIDs->size(); ++i)
    {
        data << int32((*BonusListIDs)[i]);
    }
    data << Owner;
    data << ContainedIn;
    data << Creator;
    data << GiftCreator;
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << uint32(StackCount);
        data << uint32(Expiration);
        for (std::size_t i = 0; i < 5; ++i)
        {
            data << int32(SpellCharges[i]);
        }
    }
    data << uint32(DynamicFlags);
    for (std::size_t i = 0; i < 13; ++i)
    {
        Enchantment[i].WriteCreate(data, owner, receiver);
    }
    data << int32(PropertySeed);
    data << int32(RandomPropertiesID);
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << uint32(Durability);
        data << uint32(MaxDurability);
    }
    data << uint32(CreatePlayedTime);
    data << int32(Context);
    data << int64(CreateTime);
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << uint64(ArtifactXP);
        data << uint8(ItemAppearanceModID);
    }
    data << uint32(ArtifactPowers.size());
    data << uint32(Gems.size());
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << uint32(DynamicFlags2);
        data << uint16(DEBUGItemLevel);
    }
    for (std::size_t i = 0; i < ArtifactPowers.size(); ++i)
    {
        ArtifactPowers[i].WriteCreate(data, owner, receiver);
    }
    for (std::size_t i = 0; i < Gems.size(); ++i)
    {
        Gems[i].WriteCreate(data, owner, receiver);
    }
    Modifiers->WriteCreate(data, owner, receiver);
}

void ItemData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Item const* owner, Player const* receiver) const
{
    Mask allowedMaskForTarget({ 0xE0139CFFu, 0x000007FFu });
    AppendAllowedFieldsMaskForFlag(allowedMaskForTarget, fieldVisibilityFlags);
    WriteUpdate(data, _changesMask & allowedMaskForTarget, false, owner, receiver);
}

void ItemData::AppendAllowedFieldsMaskForFlag(Mask& allowedMaskForTarget, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags) const
{
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
        allowedMaskForTarget |= { 0x1FEC6300u, 0x00000000u };
}

void ItemData::FilterDisallowedFieldsMaskForFlag(Mask& changesMask, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags) const
{
    Mask allowedMaskForTarget({ 0xE0139CFFu, 0x000007FFu });
    AppendAllowedFieldsMaskForFlag(allowedMaskForTarget, fieldVisibilityFlags);
    changesMask &= allowedMaskForTarget;
}

void ItemData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, Item const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlocksMask(0), 2);
    for (std::size_t i = 0; i < 2; ++i)
        if (changesMask.GetBlock(i))
            data.WriteBits(changesMask.GetBlock(i), 32);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBits(BonusListIDs->size(), 32);
            for (std::size_t i = 0; i < BonusListIDs->size(); ++i)
            {
                data << int32((*BonusListIDs)[i]);
            }
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            if (!ignoreNestedChangesMask)
                ArtifactPowers.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(ArtifactPowers.size(), data);
        }
        if (changesMask[3])
        {
            if (!ignoreNestedChangesMask)
                Gems.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(Gems.size(), data);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            for (std::size_t i = 0; i < ArtifactPowers.size(); ++i)
            {
                if (ArtifactPowers.HasChanged(i) || ignoreNestedChangesMask)
                {
                    ArtifactPowers[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[3])
        {
            for (std::size_t i = 0; i < Gems.size(); ++i)
            {
                if (Gems.HasChanged(i) || ignoreNestedChangesMask)
                {
                    Gems[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[4])
        {
            data << Owner;
        }
        if (changesMask[5])
        {
            data << ContainedIn;
        }
        if (changesMask[6])
        {
            data << Creator;
        }
        if (changesMask[7])
        {
            data << GiftCreator;
        }
        if (changesMask[8])
        {
            data << uint32(StackCount);
        }
        if (changesMask[9])
        {
            data << uint32(Expiration);
        }
        if (changesMask[10])
        {
            data << uint32(DynamicFlags);
        }
        if (changesMask[11])
        {
            data << int32(PropertySeed);
        }
        if (changesMask[12])
        {
            data << int32(RandomPropertiesID);
        }
        if (changesMask[13])
        {
            data << uint32(Durability);
        }
        if (changesMask[14])
        {
            data << uint32(MaxDurability);
        }
        if (changesMask[15])
        {
            data << uint32(CreatePlayedTime);
        }
        if (changesMask[16])
        {
            data << int32(Context);
        }
        if (changesMask[17])
        {
            data << int64(CreateTime);
        }
        if (changesMask[18])
        {
            data << uint64(ArtifactXP);
        }
        if (changesMask[19])
        {
            data << uint8(ItemAppearanceModID);
        }
        if (changesMask[21])
        {
            data << uint32(DynamicFlags2);
        }
        if (changesMask[22])
        {
            data << uint16(DEBUGItemLevel);
        }
        if (changesMask[20])
        {
            Modifiers->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
    }
    if (changesMask[23])
    {
        for (std::size_t i = 0; i < 5; ++i)
        {
            if (changesMask[24 + i])
            {
                data << int32(SpellCharges[i]);
            }
        }
    }
    if (changesMask[29])
    {
        for (std::size_t i = 0; i < 13; ++i)
        {
            if (changesMask[30 + i])
            {
                Enchantment[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
            }
        }
    }
}

void ItemData::ClearChangesMask()
{
    Base::ClearChangesMask(BonusListIDs);
    Base::ClearChangesMask(ArtifactPowers);
    Base::ClearChangesMask(Gems);
    Base::ClearChangesMask(Owner);
    Base::ClearChangesMask(ContainedIn);
    Base::ClearChangesMask(Creator);
    Base::ClearChangesMask(GiftCreator);
    Base::ClearChangesMask(StackCount);
    Base::ClearChangesMask(Expiration);
    Base::ClearChangesMask(DynamicFlags);
    Base::ClearChangesMask(PropertySeed);
    Base::ClearChangesMask(RandomPropertiesID);
    Base::ClearChangesMask(Durability);
    Base::ClearChangesMask(MaxDurability);
    Base::ClearChangesMask(CreatePlayedTime);
    Base::ClearChangesMask(Context);
    Base::ClearChangesMask(CreateTime);
    Base::ClearChangesMask(ArtifactXP);
    Base::ClearChangesMask(ItemAppearanceModID);
    Base::ClearChangesMask(Modifiers);
    Base::ClearChangesMask(DynamicFlags2);
    Base::ClearChangesMask(DEBUGItemLevel);
    Base::ClearChangesMask(SpellCharges);
    Base::ClearChangesMask(Enchantment);
    _changesMask.ResetAll();
}

void ContainerData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Bag const* owner, Player const* receiver) const
{
    for (std::size_t i = 0; i < 36; ++i)
    {
        data << Slots[i];
    }
    data << uint32(NumSlots);
}

void ContainerData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Bag const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void ContainerData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, Bag const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlocksMask(0), 2);
    for (std::size_t i = 0; i < 2; ++i)
        if (changesMask.GetBlock(i))
            data.WriteBits(changesMask.GetBlock(i), 32);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << uint32(NumSlots);
        }
    }
    if (changesMask[2])
    {
        for (std::size_t i = 0; i < 36; ++i)
        {
            if (changesMask[3 + i])
            {
                data << Slots[i];
            }
        }
    }
}

void ContainerData::ClearChangesMask()
{
    Base::ClearChangesMask(NumSlots);
    Base::ClearChangesMask(Slots);
    _changesMask.ResetAll();
}

void UnitChannel::WriteCreate(ByteBuffer& data, Unit const* owner, Player const* receiver) const
{
    data << int32(SpellID);
    data << int32(SpellXSpellVisualID);
}

void UnitChannel::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Unit const* owner, Player const* receiver) const
{
    data << int32(SpellID);
    data << int32(SpellXSpellVisualID);
}

bool UnitChannel::operator==(UnitChannel const& right) const
{
    return SpellID == right.SpellID
        && SpellXSpellVisualID == right.SpellXSpellVisualID;
}

void VisibleItem::WriteCreate(ByteBuffer& data, Unit const* owner, Player const* receiver) const
{
    data << int32(ItemID);
    data << uint16(ItemAppearanceModID);
    data << uint16(ItemVisual);
}

void VisibleItem::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Unit const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 4);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << int32(ItemID);
        }
        if (changesMask[2])
        {
            data << uint16(ItemAppearanceModID);
        }
        if (changesMask[3])
        {
            data << uint16(ItemVisual);
        }
    }
}

void VisibleItem::ClearChangesMask()
{
    Base::ClearChangesMask(ItemID);
    Base::ClearChangesMask(ItemAppearanceModID);
    Base::ClearChangesMask(ItemVisual);
    _changesMask.ResetAll();
}

void PassiveSpellHistory::WriteCreate(ByteBuffer& data, Unit const* owner, Player const* receiver) const
{
    data << int32(SpellID);
    data << int32(AuraSpellID);
}

void PassiveSpellHistory::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Unit const* owner, Player const* receiver) const
{
    data << int32(SpellID);
    data << int32(AuraSpellID);
}

bool PassiveSpellHistory::operator==(PassiveSpellHistory const& right) const
{
    return SpellID == right.SpellID
        && AuraSpellID == right.AuraSpellID;
}

void UnitData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Unit const* owner, Player const* receiver) const
{
    data << int64(Health);
    data << int64(MaxHealth);
    data << int32(ViewerDependentValue<DisplayIDTag>::GetValue(this, owner, receiver));
    for (std::size_t i = 0; i < 2; ++i)
    {
        data << uint32(ViewerDependentValue<NpcFlagsTag>::GetValue(this, i, owner, receiver));
    }
    data << uint32(StateSpellVisualID);
    data << uint32(StateAnimID);
    data << uint32(StateAnimKitID);
    data << uint32(StateWorldEffectIDs->size());
    for (std::size_t i = 0; i < StateWorldEffectIDs->size(); ++i)
    {
        data << uint32((*StateWorldEffectIDs)[i]);
    }
    data << Charm;
    data << Summon;
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << Critter;
    }
    data << CharmedBy;
    data << SummonedBy;
    data << CreatedBy;
    data << DemonCreator;
    data << LookAtControllerTarget;
    data << Target;
    data << BattlePetCompanionGUID;
    data << uint64(BattlePetDBID);
    ChannelData->WriteCreate(data, owner, receiver);
    data << uint32(SummonedByHomeRealm);
    data << uint8(Race);
    data << uint8(ClassId);
    data << uint8(PlayerClassId);
    data << uint8(Sex);
    data << uint8(DisplayPower);
    data << uint32(OverrideDisplayPowerID);
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner | UpdateFieldFlag::UnitAll))
    {
        for (std::size_t i = 0; i < 7; ++i)
        {
            data << float(Unk340[i]);
            data << float(Unk340_2[i]);
        }
    }
    for (std::size_t i = 0; i < 7; ++i)
    {
        data << int32(Power[i]);
        data << int32(MaxPower[i]);
        data << float(PowerRegenFlatModifier[i]);
    }
    data << int32(Level);
    data << int32(EffectiveLevel);
    data << int32(ContentTuningID);
    data << int32(ScalingLevelMin);
    data << int32(ScalingLevelMax);
    data << int32(ScalingLevelDelta);
    data << int32(ScalingFactionGroup);
    data << int32(ScalingHealthItemLevelCurveID);
    data << int32(ScalingDamageItemLevelCurveID);
    data << int32(ViewerDependentValue<FactionTemplateTag>::GetValue(this, owner, receiver));
    for (std::size_t i = 0; i < 3; ++i)
    {
        VirtualItems[i].WriteCreate(data, owner, receiver);
    }
    data << uint32(ViewerDependentValue<FlagsTag>::GetValue(this, owner, receiver));
    data << uint32(Flags2);
    data << uint32(Flags3);
    data << uint32(ViewerDependentValue<AuraStateTag>::GetValue(this, owner, receiver));
    for (std::size_t i = 0; i < 2; ++i)
    {
        data << uint32(AttackRoundBaseTime[i]);
    }
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << uint32(RangedAttackRoundBaseTime);
    }
    data << float(BoundingRadius);
    data << float(CombatReach);
    data << float(DisplayScale);
    data << int32(NativeDisplayID);
    data << float(NativeXDisplayScale);
    data << int32(MountDisplayID);
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner | UpdateFieldFlag::Empath))
    {
        data << float(MinDamage);
        data << float(MaxDamage);
        data << float(MinOffHandDamage);
        data << float(MaxOffHandDamage);
    }
    data << uint8(StandState);
    data << uint8(PetTalentPoints);
    data << uint8(VisFlags);
    data << uint8(AnimTier);
    data << uint32(PetNumber);
    data << uint32(PetNameTimestamp);
    data << uint32(PetExperience);
    data << uint32(PetNextLevelExperience);
    data << float(ModCastingSpeed);
    data << float(ModSpellHaste);
    data << float(ModHaste);
    data << float(ModRangedHaste);
    data << float(ModHasteRegen);
    data << float(ModTimeRate);
    data << int32(CreatedBySpell);
    data << int32(EmoteState);
    data << uint16(TrainingPointsUsed);
    data << uint16(TrainingPointsTotal);
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        for (std::size_t i = 0; i < 5; ++i)
        {
            data << int32(Stats[i]);
            data << int32(StatPosBuff[i]);
            data << int32(StatNegBuff[i]);
        }
    }
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner | UpdateFieldFlag::Empath))
    {
        for (std::size_t i = 0; i < 7; ++i)
        {
            data << int32(Resistances[i]);
        }
    }
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        for (std::size_t i = 0; i < 7; ++i)
        {
            data << int32(PowerCostModifier[i]);
            data << float(PowerCostMultiplier[i]);
        }
    }
    for (std::size_t i = 0; i < 7; ++i)
    {
        data << int32(ResistanceBuffModsPositive[i]);
        data << int32(ResistanceBuffModsNegative[i]);
    }
    data << int32(BaseMana);
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << int32(BaseHealth);
    }
    data << uint8(SheatheState);
    data << uint8(ViewerDependentValue<PvpFlagsTag>::GetValue(this, owner, receiver));
    data << uint8(PetFlags);
    data << uint8(ShapeshiftForm);
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << int32(AttackPower);
        data << int32(AttackPowerModPos);
        data << int32(AttackPowerModNeg);
        data << float(AttackPowerMultiplier);
        data << int32(RangedAttackPower);
        data << int32(RangedAttackPowerModPos);
        data << int32(RangedAttackPowerModNeg);
        data << float(RangedAttackPowerMultiplier);
        data << int32(SetAttackSpeedAura);
        data << float(Lifesteal);
        data << float(MinRangedDamage);
        data << float(MaxRangedDamage);
        data << float(MaxHealthModifier);
    }
    data << float(HoverHeight);
    data << int32(MinItemLevelCutoff);
    data << int32(MinItemLevel);
    data << int32(MaxItemLevel);
    data << int32(WildBattlePetLevel);
    data << uint32(BattlePetCompanionNameTimestamp);
    data << int32(InteractSpellID);
    data << int32(ScaleDuration);
    data << int32(LooksLikeMountID);
    data << int32(LooksLikeCreatureID);
    data << int32(LookAtControllerID);
    data << GuildGUID;
    data << uint32(PassiveSpells.size());
    data << uint32(WorldEffects.size());
    data << uint32(ChannelObjects.size());
    data << SkinningOwnerGUID;
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
    {
        data << Unk340_3;
    }
    for (std::size_t i = 0; i < PassiveSpells.size(); ++i)
    {
        PassiveSpells[i].WriteCreate(data, owner, receiver);
    }
    for (std::size_t i = 0; i < WorldEffects.size(); ++i)
    {
        data << int32(WorldEffects[i]);
    }
    for (std::size_t i = 0; i < ChannelObjects.size(); ++i)
    {
        data << ChannelObjects[i];
    }
}

void UnitData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Unit const* owner, Player const* receiver) const
{
    Mask allowedMaskForTarget({ 0xFFFFDFFFu, 0xFF0FDFFFu, 0xC001EFFFu, 0x8001EFFFu, 0x07FFFFFFu, 0x00000800u, 0x00007FFEu });
    AppendAllowedFieldsMaskForFlag(allowedMaskForTarget, fieldVisibilityFlags);
    WriteUpdate(data, _changesMask & allowedMaskForTarget, false, owner, receiver);
}

void UnitData::AppendAllowedFieldsMaskForFlag(Mask& allowedMaskForTarget, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags) const
{
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Owner))
        allowedMaskForTarget |= { 0x00002000u, 0x00F02000u, 0x3FFE1000u, 0x7FFF1000u, 0xF8000000u, 0xFFFFFFFFu, 0x00000001u };
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::UnitAll))
        allowedMaskForTarget |= { 0x00000000u, 0x00000000u, 0x00000000u, 0x7FFF0000u, 0x00000000u, 0x00000000u, 0x00000000u };
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::Empath))
        allowedMaskForTarget |= { 0x00000000u, 0x00F00000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x0007F800u, 0x00000000u };
}

void UnitData::FilterDisallowedFieldsMaskForFlag(Mask& changesMask, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags) const
{
    Mask allowedMaskForTarget({ 0xFFFFDFFFu, 0xFF0FDFFFu, 0xC001EFFFu, 0x8001EFFFu, 0x07FFFFFFu, 0x00000800u, 0x00007FFEu });
    AppendAllowedFieldsMaskForFlag(allowedMaskForTarget, fieldVisibilityFlags);
    changesMask &= allowedMaskForTarget;
}

void UnitData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, Unit const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlocksMask(0), 7);
    for (std::size_t i = 0; i < 7; ++i)
        if (changesMask.GetBlock(i))
            data.WriteBits(changesMask.GetBlock(i), 32);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBits(StateWorldEffectIDs->size(), 32);
            for (std::size_t i = 0; i < StateWorldEffectIDs->size(); ++i)
            {
                data << uint32((*StateWorldEffectIDs)[i]);
            }
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            if (!ignoreNestedChangesMask)
                PassiveSpells.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(PassiveSpells.size(), data);
        }
        if (changesMask[3])
        {
            if (!ignoreNestedChangesMask)
                WorldEffects.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(WorldEffects.size(), data);
        }
        if (changesMask[4])
        {
            if (!ignoreNestedChangesMask)
                ChannelObjects.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(ChannelObjects.size(), data);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            for (std::size_t i = 0; i < PassiveSpells.size(); ++i)
            {
                if (PassiveSpells.HasChanged(i) || ignoreNestedChangesMask)
                {
                    PassiveSpells[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[3])
        {
            for (std::size_t i = 0; i < WorldEffects.size(); ++i)
            {
                if (WorldEffects.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(WorldEffects[i]);
                }
            }
        }
        if (changesMask[4])
        {
            for (std::size_t i = 0; i < ChannelObjects.size(); ++i)
            {
                if (ChannelObjects.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << ChannelObjects[i];
                }
            }
        }
        if (changesMask[5])
        {
            data << int64(Health);
        }
        if (changesMask[6])
        {
            data << int64(MaxHealth);
        }
        if (changesMask[7])
        {
            data << int32(ViewerDependentValue<DisplayIDTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[8])
        {
            data << uint32(StateSpellVisualID);
        }
        if (changesMask[9])
        {
            data << uint32(StateAnimID);
        }
        if (changesMask[10])
        {
            data << uint32(StateAnimKitID);
        }
        if (changesMask[11])
        {
            data << Charm;
        }
        if (changesMask[12])
        {
            data << Summon;
        }
        if (changesMask[13])
        {
            data << Critter;
        }
        if (changesMask[14])
        {
            data << CharmedBy;
        }
        if (changesMask[15])
        {
            data << SummonedBy;
        }
        if (changesMask[16])
        {
            data << CreatedBy;
        }
        if (changesMask[17])
        {
            data << DemonCreator;
        }
        if (changesMask[18])
        {
            data << LookAtControllerTarget;
        }
        if (changesMask[19])
        {
            data << Target;
        }
        if (changesMask[20])
        {
            data << BattlePetCompanionGUID;
        }
        if (changesMask[21])
        {
            data << uint64(BattlePetDBID);
        }
        if (changesMask[22])
        {
            ChannelData->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
        if (changesMask[23])
        {
            data << uint32(SummonedByHomeRealm);
        }
        if (changesMask[24])
        {
            data << uint8(Race);
        }
        if (changesMask[25])
        {
            data << uint8(ClassId);
        }
        if (changesMask[26])
        {
            data << uint8(PlayerClassId);
        }
        if (changesMask[27])
        {
            data << uint8(Sex);
        }
        if (changesMask[28])
        {
            data << uint8(DisplayPower);
        }
        if (changesMask[29])
        {
            data << uint32(OverrideDisplayPowerID);
        }
        if (changesMask[30])
        {
            data << int32(Level);
        }
        if (changesMask[31])
        {
            data << int32(EffectiveLevel);
        }
    }
    if (changesMask[32])
    {
        if (changesMask[33])
        {
            data << int32(ContentTuningID);
        }
        if (changesMask[34])
        {
            data << int32(ScalingLevelMin);
        }
        if (changesMask[35])
        {
            data << int32(ScalingLevelMax);
        }
        if (changesMask[36])
        {
            data << int32(ScalingLevelDelta);
        }
        if (changesMask[37])
        {
            data << int32(ScalingFactionGroup);
        }
        if (changesMask[38])
        {
            data << int32(ScalingHealthItemLevelCurveID);
        }
        if (changesMask[39])
        {
            data << int32(ScalingDamageItemLevelCurveID);
        }
        if (changesMask[40])
        {
            data << int32(ViewerDependentValue<FactionTemplateTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[41])
        {
            data << uint32(ViewerDependentValue<FlagsTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[42])
        {
            data << uint32(Flags2);
        }
        if (changesMask[43])
        {
            data << uint32(Flags3);
        }
        if (changesMask[44])
        {
            data << uint32(ViewerDependentValue<AuraStateTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[45])
        {
            data << uint32(RangedAttackRoundBaseTime);
        }
        if (changesMask[46])
        {
            data << float(BoundingRadius);
        }
        if (changesMask[47])
        {
            data << float(CombatReach);
        }
        if (changesMask[48])
        {
            data << float(DisplayScale);
        }
        if (changesMask[49])
        {
            data << int32(NativeDisplayID);
        }
        if (changesMask[50])
        {
            data << float(NativeXDisplayScale);
        }
        if (changesMask[51])
        {
            data << int32(MountDisplayID);
        }
        if (changesMask[52])
        {
            data << float(MinDamage);
        }
        if (changesMask[53])
        {
            data << float(MaxDamage);
        }
        if (changesMask[54])
        {
            data << float(MinOffHandDamage);
        }
        if (changesMask[55])
        {
            data << float(MaxOffHandDamage);
        }
        if (changesMask[56])
        {
            data << uint8(StandState);
        }
        if (changesMask[57])
        {
            data << uint8(PetTalentPoints);
        }
        if (changesMask[58])
        {
            data << uint8(VisFlags);
        }
        if (changesMask[59])
        {
            data << uint8(AnimTier);
        }
        if (changesMask[60])
        {
            data << uint32(PetNumber);
        }
        if (changesMask[61])
        {
            data << uint32(PetNameTimestamp);
        }
        if (changesMask[62])
        {
            data << uint32(PetExperience);
        }
        if (changesMask[63])
        {
            data << uint32(PetNextLevelExperience);
        }
    }
    if (changesMask[64])
    {
        if (changesMask[65])
        {
            data << float(ModCastingSpeed);
        }
        if (changesMask[66])
        {
            data << float(ModSpellHaste);
        }
        if (changesMask[67])
        {
            data << float(ModHaste);
        }
        if (changesMask[68])
        {
            data << float(ModRangedHaste);
        }
        if (changesMask[69])
        {
            data << float(ModHasteRegen);
        }
        if (changesMask[70])
        {
            data << float(ModTimeRate);
        }
        if (changesMask[71])
        {
            data << int32(CreatedBySpell);
        }
        if (changesMask[72])
        {
            data << int32(EmoteState);
        }
        if (changesMask[73])
        {
            data << uint16(TrainingPointsUsed);
        }
        if (changesMask[74])
        {
            data << uint16(TrainingPointsTotal);
        }
        if (changesMask[75])
        {
            data << int32(BaseMana);
        }
        if (changesMask[76])
        {
            data << int32(BaseHealth);
        }
        if (changesMask[77])
        {
            data << uint8(SheatheState);
        }
        if (changesMask[78])
        {
            data << uint8(ViewerDependentValue<PvpFlagsTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[79])
        {
            data << uint8(PetFlags);
        }
        if (changesMask[80])
        {
            data << uint8(ShapeshiftForm);
        }
        if (changesMask[81])
        {
            data << int32(AttackPower);
        }
        if (changesMask[82])
        {
            data << int32(AttackPowerModPos);
        }
        if (changesMask[83])
        {
            data << int32(AttackPowerModNeg);
        }
        if (changesMask[84])
        {
            data << float(AttackPowerMultiplier);
        }
        if (changesMask[85])
        {
            data << int32(RangedAttackPower);
        }
        if (changesMask[86])
        {
            data << int32(RangedAttackPowerModPos);
        }
        if (changesMask[87])
        {
            data << int32(RangedAttackPowerModNeg);
        }
        if (changesMask[88])
        {
            data << float(RangedAttackPowerMultiplier);
        }
        if (changesMask[89])
        {
            data << int32(SetAttackSpeedAura);
        }
        if (changesMask[90])
        {
            data << float(Lifesteal);
        }
        if (changesMask[91])
        {
            data << float(MinRangedDamage);
        }
        if (changesMask[92])
        {
            data << float(MaxRangedDamage);
        }
        if (changesMask[93])
        {
            data << float(MaxHealthModifier);
        }
        if (changesMask[94])
        {
            data << float(HoverHeight);
        }
        if (changesMask[95])
        {
            data << int32(MinItemLevelCutoff);
        }
    }
    if (changesMask[96])
    {
        if (changesMask[97])
        {
            data << int32(MinItemLevel);
        }
        if (changesMask[98])
        {
            data << int32(MaxItemLevel);
        }
        if (changesMask[99])
        {
            data << int32(WildBattlePetLevel);
        }
        if (changesMask[100])
        {
            data << uint32(BattlePetCompanionNameTimestamp);
        }
        if (changesMask[101])
        {
            data << int32(InteractSpellID);
        }
        if (changesMask[102])
        {
            data << int32(ScaleDuration);
        }
        if (changesMask[103])
        {
            data << int32(LooksLikeMountID);
        }
        if (changesMask[104])
        {
            data << int32(LooksLikeCreatureID);
        }
        if (changesMask[105])
        {
            data << int32(LookAtControllerID);
        }
        if (changesMask[106])
        {
            data << GuildGUID;
        }
        if (changesMask[107])
        {
            data << SkinningOwnerGUID;
        }
        if (changesMask[108])
        {
            data << Unk340_3;
        }
    }
    if (changesMask[109])
    {
        for (std::size_t i = 0; i < 2; ++i)
        {
            if (changesMask[110 + i])
            {
                data << uint32(ViewerDependentValue<NpcFlagsTag>::GetValue(this, i, owner, receiver));
            }
        }
    }
    if (changesMask[112])
    {
        for (std::size_t i = 0; i < 7; ++i)
        {
            if (changesMask[113 + i])
            {
                data << float(Unk340[i]);
            }
            if (changesMask[120 + i])
            {
                data << float(Unk340_2[i]);
            }
            if (changesMask[127 + i])
            {
                data << int32(Power[i]);
            }
            if (changesMask[134 + i])
            {
                data << int32(MaxPower[i]);
            }
            if (changesMask[141 + i])
            {
                data << float(PowerRegenFlatModifier[i]);
            }
        }
    }
    if (changesMask[148])
    {
        for (std::size_t i = 0; i < 3; ++i)
        {
            if (changesMask[149 + i])
            {
                VirtualItems[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
            }
        }
    }
    if (changesMask[152])
    {
        for (std::size_t i = 0; i < 2; ++i)
        {
            if (changesMask[153 + i])
            {
                data << uint32(AttackRoundBaseTime[i]);
            }
        }
    }
    if (changesMask[155])
    {
        for (std::size_t i = 0; i < 5; ++i)
        {
            if (changesMask[156 + i])
            {
                data << int32(Stats[i]);
            }
            if (changesMask[161 + i])
            {
                data << int32(StatPosBuff[i]);
            }
            if (changesMask[166 + i])
            {
                data << int32(StatNegBuff[i]);
            }
        }
    }
    if (changesMask[171])
    {
        for (std::size_t i = 0; i < 7; ++i)
        {
            if (changesMask[172 + i])
            {
                data << int32(Resistances[i]);
            }
            if (changesMask[179 + i])
            {
                data << int32(PowerCostModifier[i]);
            }
            if (changesMask[186 + i])
            {
                data << float(PowerCostMultiplier[i]);
            }
        }
    }
    if (changesMask[193])
    {
        for (std::size_t i = 0; i < 7; ++i)
        {
            if (changesMask[194 + i])
            {
                data << int32(ResistanceBuffModsPositive[i]);
            }
            if (changesMask[201 + i])
            {
                data << int32(ResistanceBuffModsNegative[i]);
            }
        }
    }
}

void UnitData::ClearChangesMask()
{
    Base::ClearChangesMask(StateWorldEffectIDs);
    Base::ClearChangesMask(PassiveSpells);
    Base::ClearChangesMask(WorldEffects);
    Base::ClearChangesMask(ChannelObjects);
    Base::ClearChangesMask(Health);
    Base::ClearChangesMask(MaxHealth);
    Base::ClearChangesMask(DisplayID);
    Base::ClearChangesMask(StateSpellVisualID);
    Base::ClearChangesMask(StateAnimID);
    Base::ClearChangesMask(StateAnimKitID);
    Base::ClearChangesMask(Charm);
    Base::ClearChangesMask(Summon);
    Base::ClearChangesMask(Critter);
    Base::ClearChangesMask(CharmedBy);
    Base::ClearChangesMask(SummonedBy);
    Base::ClearChangesMask(CreatedBy);
    Base::ClearChangesMask(DemonCreator);
    Base::ClearChangesMask(LookAtControllerTarget);
    Base::ClearChangesMask(Target);
    Base::ClearChangesMask(BattlePetCompanionGUID);
    Base::ClearChangesMask(BattlePetDBID);
    Base::ClearChangesMask(ChannelData);
    Base::ClearChangesMask(SummonedByHomeRealm);
    Base::ClearChangesMask(Race);
    Base::ClearChangesMask(ClassId);
    Base::ClearChangesMask(PlayerClassId);
    Base::ClearChangesMask(Sex);
    Base::ClearChangesMask(DisplayPower);
    Base::ClearChangesMask(OverrideDisplayPowerID);
    Base::ClearChangesMask(Level);
    Base::ClearChangesMask(EffectiveLevel);
    Base::ClearChangesMask(ContentTuningID);
    Base::ClearChangesMask(ScalingLevelMin);
    Base::ClearChangesMask(ScalingLevelMax);
    Base::ClearChangesMask(ScalingLevelDelta);
    Base::ClearChangesMask(ScalingFactionGroup);
    Base::ClearChangesMask(ScalingHealthItemLevelCurveID);
    Base::ClearChangesMask(ScalingDamageItemLevelCurveID);
    Base::ClearChangesMask(FactionTemplate);
    Base::ClearChangesMask(Flags);
    Base::ClearChangesMask(Flags2);
    Base::ClearChangesMask(Flags3);
    Base::ClearChangesMask(AuraState);
    Base::ClearChangesMask(RangedAttackRoundBaseTime);
    Base::ClearChangesMask(BoundingRadius);
    Base::ClearChangesMask(CombatReach);
    Base::ClearChangesMask(DisplayScale);
    Base::ClearChangesMask(NativeDisplayID);
    Base::ClearChangesMask(NativeXDisplayScale);
    Base::ClearChangesMask(MountDisplayID);
    Base::ClearChangesMask(MinDamage);
    Base::ClearChangesMask(MaxDamage);
    Base::ClearChangesMask(MinOffHandDamage);
    Base::ClearChangesMask(MaxOffHandDamage);
    Base::ClearChangesMask(StandState);
    Base::ClearChangesMask(PetTalentPoints);
    Base::ClearChangesMask(VisFlags);
    Base::ClearChangesMask(AnimTier);
    Base::ClearChangesMask(PetNumber);
    Base::ClearChangesMask(PetNameTimestamp);
    Base::ClearChangesMask(PetExperience);
    Base::ClearChangesMask(PetNextLevelExperience);
    Base::ClearChangesMask(ModCastingSpeed);
    Base::ClearChangesMask(ModSpellHaste);
    Base::ClearChangesMask(ModHaste);
    Base::ClearChangesMask(ModRangedHaste);
    Base::ClearChangesMask(ModHasteRegen);
    Base::ClearChangesMask(ModTimeRate);
    Base::ClearChangesMask(CreatedBySpell);
    Base::ClearChangesMask(EmoteState);
    Base::ClearChangesMask(TrainingPointsUsed);
    Base::ClearChangesMask(TrainingPointsTotal);
    Base::ClearChangesMask(BaseMana);
    Base::ClearChangesMask(BaseHealth);
    Base::ClearChangesMask(SheatheState);
    Base::ClearChangesMask(PvpFlags);
    Base::ClearChangesMask(PetFlags);
    Base::ClearChangesMask(ShapeshiftForm);
    Base::ClearChangesMask(AttackPower);
    Base::ClearChangesMask(AttackPowerModPos);
    Base::ClearChangesMask(AttackPowerModNeg);
    Base::ClearChangesMask(AttackPowerMultiplier);
    Base::ClearChangesMask(RangedAttackPower);
    Base::ClearChangesMask(RangedAttackPowerModPos);
    Base::ClearChangesMask(RangedAttackPowerModNeg);
    Base::ClearChangesMask(RangedAttackPowerMultiplier);
    Base::ClearChangesMask(SetAttackSpeedAura);
    Base::ClearChangesMask(Lifesteal);
    Base::ClearChangesMask(MinRangedDamage);
    Base::ClearChangesMask(MaxRangedDamage);
    Base::ClearChangesMask(MaxHealthModifier);
    Base::ClearChangesMask(HoverHeight);
    Base::ClearChangesMask(MinItemLevelCutoff);
    Base::ClearChangesMask(MinItemLevel);
    Base::ClearChangesMask(MaxItemLevel);
    Base::ClearChangesMask(WildBattlePetLevel);
    Base::ClearChangesMask(BattlePetCompanionNameTimestamp);
    Base::ClearChangesMask(InteractSpellID);
    Base::ClearChangesMask(ScaleDuration);
    Base::ClearChangesMask(LooksLikeMountID);
    Base::ClearChangesMask(LooksLikeCreatureID);
    Base::ClearChangesMask(LookAtControllerID);
    Base::ClearChangesMask(GuildGUID);
    Base::ClearChangesMask(SkinningOwnerGUID);
    Base::ClearChangesMask(Unk340_3);
    Base::ClearChangesMask(NpcFlags);
    Base::ClearChangesMask(Unk340);
    Base::ClearChangesMask(Unk340_2);
    Base::ClearChangesMask(Power);
    Base::ClearChangesMask(MaxPower);
    Base::ClearChangesMask(PowerRegenFlatModifier);
    Base::ClearChangesMask(VirtualItems);
    Base::ClearChangesMask(AttackRoundBaseTime);
    Base::ClearChangesMask(Stats);
    Base::ClearChangesMask(StatPosBuff);
    Base::ClearChangesMask(StatNegBuff);
    Base::ClearChangesMask(Resistances);
    Base::ClearChangesMask(PowerCostModifier);
    Base::ClearChangesMask(PowerCostMultiplier);
    Base::ClearChangesMask(ResistanceBuffModsPositive);
    Base::ClearChangesMask(ResistanceBuffModsNegative);
    _changesMask.ResetAll();
}

void ChrCustomizationChoice::WriteCreate(ByteBuffer& data, Object const* owner, Player const* receiver) const
{
    data << uint32(ChrCustomizationOptionID);
    data << uint32(ChrCustomizationChoiceID);
}

void ChrCustomizationChoice::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Object const* owner, Player const* receiver) const
{
    data << uint32(ChrCustomizationOptionID);
    data << uint32(ChrCustomizationChoiceID);
}

bool ChrCustomizationChoice::operator==(ChrCustomizationChoice const& right) const
{
    return ChrCustomizationOptionID == right.ChrCustomizationOptionID
        && ChrCustomizationChoiceID == right.ChrCustomizationChoiceID;
}

void QuestLog::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(QuestID);
    data << uint32(StateFlags);
    data << uint32(EndTime);
    data << uint32(AcceptTime);
    for (std::size_t i = 0; i < 24; ++i)
    {
        data << uint16(ObjectiveProgress[i]);
    }
}

void QuestLog::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlocksMask(0), 1);
    if (changesMask.GetBlock(0))
        data.WriteBits(changesMask.GetBlock(0), 32);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << int32(QuestID);
        }
        if (changesMask[2])
        {
            data << uint32(StateFlags);
        }
        if (changesMask[3])
        {
            data << uint32(EndTime);
        }
        if (changesMask[4])
        {
            data << uint32(AcceptTime);
        }
    }
    if (changesMask[5])
    {
        for (std::size_t i = 0; i < 24; ++i)
        {
            if (changesMask[6 + i])
            {
                data << uint16(ObjectiveProgress[i]);
            }
        }
    }
}

void QuestLog::ClearChangesMask()
{
    Base::ClearChangesMask(QuestID);
    Base::ClearChangesMask(StateFlags);
    Base::ClearChangesMask(EndTime);
    Base::ClearChangesMask(AcceptTime);
    Base::ClearChangesMask(ObjectiveProgress);
    _changesMask.ResetAll();
}

void ArenaCooldown::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(SpellID);
    data << int32(Charges);
    data << int32(Unk254);
    data << uint32(Flags);
    data << uint32(StartTime);
    data << uint32(EndTime);
    data << uint32(NextChargeTime);
    data << uint8(MaxCharges);
}

void ArenaCooldown::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 9);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << int32(SpellID);
        }
        if (changesMask[2])
        {
            data << int32(Charges);
        }
        if (changesMask[3])
        {
            data << int32(Unk254);
        }
        if (changesMask[4])
        {
            data << uint32(Flags);
        }
        if (changesMask[5])
        {
            data << uint32(StartTime);
        }
        if (changesMask[6])
        {
            data << uint32(EndTime);
        }
        if (changesMask[7])
        {
            data << uint32(NextChargeTime);
        }
        if (changesMask[8])
        {
            data << uint8(MaxCharges);
        }
    }
}

void ArenaCooldown::ClearChangesMask()
{
    Base::ClearChangesMask(SpellID);
    Base::ClearChangesMask(Charges);
    Base::ClearChangesMask(Unk254);
    Base::ClearChangesMask(Flags);
    Base::ClearChangesMask(StartTime);
    Base::ClearChangesMask(EndTime);
    Base::ClearChangesMask(NextChargeTime);
    Base::ClearChangesMask(MaxCharges);
    _changesMask.ResetAll();
}

void PlayerData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Player const* owner, Player const* receiver) const
{
    data << DuelArbiter;
    data << WowAccount;
    data << LootTargetGUID;
    data << uint32(PlayerFlags);
    data << uint32(PlayerFlagsEx);
    data << uint32(GuildRankID);
    data << uint32(GuildDeleteDate);
    data << int32(GuildLevel);
    data << uint32(Customizations.size());
    data << uint8(PartyType);
    data << uint8(NativeSex);
    data << uint8(Inebriation);
    data << uint8(PvpTitle);
    data << uint8(ArenaFaction);
    data << uint8(PvpRank);
    data << uint8(Unk254);
    data << uint32(DuelTeam);
    data << int32(GuildTimeStamp);
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::PartyMember))
    {
        for (std::size_t i = 0; i < 25; ++i)
        {
            QuestLog[i].WriteCreate(data, owner, receiver);
        }
    }
    for (std::size_t i = 0; i < 19; ++i)
    {
        VisibleItems[i].WriteCreate(data, owner, receiver);
    }
    data << int32(PlayerTitle);
    data << int32(FakeInebriation);
    data << uint32(VirtualPlayerRealm);
    data << uint32(CurrentSpecID);
    data << int32(TaxiMountAnimKitID);
    for (std::size_t i = 0; i < 6; ++i)
    {
        data << float(AvgItemLevel[i]);
    }
    data << uint8(CurrentBattlePetBreedQuality);
    data << int32(HonorLevel);
    data << uint32(ArenaCooldowns.size());
    for (std::size_t i = 0; i < Customizations.size(); ++i)
    {
        Customizations[i].WriteCreate(data, owner, receiver);
    }
    for (std::size_t i = 0; i < ArenaCooldowns.size(); ++i)
    {
        ArenaCooldowns[i].WriteCreate(data, owner, receiver);
    }
}

void PlayerData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Player const* owner, Player const* receiver) const
{
    Mask allowedMaskForTarget({ 0x07FFFFFFu, 0xFFE00000u, 0x0000FFFFu });
    AppendAllowedFieldsMaskForFlag(allowedMaskForTarget, fieldVisibilityFlags);
    WriteUpdate(data, _changesMask & allowedMaskForTarget, false, owner, receiver);
}

void PlayerData::AppendAllowedFieldsMaskForFlag(Mask& allowedMaskForTarget, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags) const
{
    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::PartyMember))
        allowedMaskForTarget |= { 0xF8000000u, 0x001FFFFFu, 0x00000000u };
}

void PlayerData::FilterDisallowedFieldsMaskForFlag(Mask& changesMask, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags) const
{
    Mask allowedMaskForTarget({ 0x07FFFFFFu, 0xFFE00000u, 0x0000FFFFu });
    AppendAllowedFieldsMaskForFlag(allowedMaskForTarget, fieldVisibilityFlags);
    changesMask &= allowedMaskForTarget;
}

void PlayerData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, Player const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlocksMask(0), 3);
    for (std::size_t i = 0; i < 3; ++i)
        if (changesMask.GetBlock(i))
            data.WriteBits(changesMask.GetBlock(i), 32);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            if (!ignoreNestedChangesMask)
                Customizations.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(Customizations.size(), data);
        }
        if (changesMask[2])
        {
            if (!ignoreNestedChangesMask)
                ArenaCooldowns.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(ArenaCooldowns.size(), data);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            for (std::size_t i = 0; i < Customizations.size(); ++i)
            {
                if (Customizations.HasChanged(i) || ignoreNestedChangesMask)
                {
                    Customizations[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[2])
        {
            for (std::size_t i = 0; i < ArenaCooldowns.size(); ++i)
            {
                if (ArenaCooldowns.HasChanged(i) || ignoreNestedChangesMask)
                {
                    ArenaCooldowns[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[3])
        {
            data << DuelArbiter;
        }
        if (changesMask[4])
        {
            data << WowAccount;
        }
        if (changesMask[5])
        {
            data << LootTargetGUID;
        }
        if (changesMask[6])
        {
            data << uint32(PlayerFlags);
        }
        if (changesMask[7])
        {
            data << uint32(PlayerFlagsEx);
        }
        if (changesMask[8])
        {
            data << uint32(GuildRankID);
        }
        if (changesMask[9])
        {
            data << uint32(GuildDeleteDate);
        }
        if (changesMask[10])
        {
            data << int32(GuildLevel);
        }
        if (changesMask[11])
        {
            data << uint8(PartyType);
        }
        if (changesMask[12])
        {
            data << uint8(NativeSex);
        }
        if (changesMask[13])
        {
            data << uint8(Inebriation);
        }
        if (changesMask[14])
        {
            data << uint8(PvpTitle);
        }
        if (changesMask[15])
        {
            data << uint8(ArenaFaction);
        }
        if (changesMask[16])
        {
            data << uint8(PvpRank);
        }
        if (changesMask[17])
        {
            data << uint8(Unk254);
        }
        if (changesMask[18])
        {
            data << uint32(DuelTeam);
        }
        if (changesMask[19])
        {
            data << int32(GuildTimeStamp);
        }
        if (changesMask[20])
        {
            data << int32(PlayerTitle);
        }
        if (changesMask[21])
        {
            data << int32(FakeInebriation);
        }
        if (changesMask[22])
        {
            data << uint32(VirtualPlayerRealm);
        }
        if (changesMask[23])
        {
            data << uint32(CurrentSpecID);
        }
        if (changesMask[24])
        {
            data << int32(TaxiMountAnimKitID);
        }
        if (changesMask[25])
        {
            data << uint8(CurrentBattlePetBreedQuality);
        }
        if (changesMask[26])
        {
            data << int32(HonorLevel);
        }
    }
    if (changesMask[27])
    {
        for (std::size_t i = 0; i < 25; ++i)
        {
            if (changesMask[28 + i])
            {
                QuestLog[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
            }
        }
    }
    if (changesMask[53])
    {
        for (std::size_t i = 0; i < 19; ++i)
        {
            if (changesMask[54 + i])
            {
                VisibleItems[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
            }
        }
    }
    if (changesMask[73])
    {
        for (std::size_t i = 0; i < 6; ++i)
        {
            if (changesMask[74 + i])
            {
                data << float(AvgItemLevel[i]);
            }
        }
    }
}

void PlayerData::ClearChangesMask()
{
    Base::ClearChangesMask(Customizations);
    Base::ClearChangesMask(ArenaCooldowns);
    Base::ClearChangesMask(DuelArbiter);
    Base::ClearChangesMask(WowAccount);
    Base::ClearChangesMask(LootTargetGUID);
    Base::ClearChangesMask(PlayerFlags);
    Base::ClearChangesMask(PlayerFlagsEx);
    Base::ClearChangesMask(GuildRankID);
    Base::ClearChangesMask(GuildDeleteDate);
    Base::ClearChangesMask(GuildLevel);
    Base::ClearChangesMask(PartyType);
    Base::ClearChangesMask(NativeSex);
    Base::ClearChangesMask(Inebriation);
    Base::ClearChangesMask(PvpTitle);
    Base::ClearChangesMask(ArenaFaction);
    Base::ClearChangesMask(PvpRank);
    Base::ClearChangesMask(Unk254);
    Base::ClearChangesMask(DuelTeam);
    Base::ClearChangesMask(GuildTimeStamp);
    Base::ClearChangesMask(PlayerTitle);
    Base::ClearChangesMask(FakeInebriation);
    Base::ClearChangesMask(VirtualPlayerRealm);
    Base::ClearChangesMask(CurrentSpecID);
    Base::ClearChangesMask(TaxiMountAnimKitID);
    Base::ClearChangesMask(CurrentBattlePetBreedQuality);
    Base::ClearChangesMask(HonorLevel);
    Base::ClearChangesMask(QuestLog);
    Base::ClearChangesMask(VisibleItems);
    Base::ClearChangesMask(AvgItemLevel);
    _changesMask.ResetAll();
}

void SkillInfo::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    for (std::size_t i = 0; i < 256; ++i)
    {
        data << uint16(SkillLineID[i]);
        data << uint16(SkillStep[i]);
        data << uint16(SkillRank[i]);
        data << uint16(SkillStartingRank[i]);
        data << uint16(SkillMaxRank[i]);
        data << int16(SkillTempBonus[i]);
        data << uint16(SkillPermBonus[i]);
    }
}

void SkillInfo::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    for (std::size_t i = 0; i < 1; ++i)
        data << uint32(changesMask.GetBlocksMask(i));
    data.WriteBits(changesMask.GetBlocksMask(1), 25);
    for (std::size_t i = 0; i < 57; ++i)
        if (changesMask.GetBlock(i))
            data.WriteBits(changesMask.GetBlock(i), 32);

    data.FlushBits();
    if (changesMask[0])
    {
        for (std::size_t i = 0; i < 256; ++i)
        {
            if (changesMask[1 + i])
            {
                data << uint16(SkillLineID[i]);
            }
            if (changesMask[257 + i])
            {
                data << uint16(SkillStep[i]);
            }
            if (changesMask[513 + i])
            {
                data << uint16(SkillRank[i]);
            }
            if (changesMask[769 + i])
            {
                data << uint16(SkillStartingRank[i]);
            }
            if (changesMask[1025 + i])
            {
                data << uint16(SkillMaxRank[i]);
            }
            if (changesMask[1281 + i])
            {
                data << int16(SkillTempBonus[i]);
            }
            if (changesMask[1537 + i])
            {
                data << uint16(SkillPermBonus[i]);
            }
        }
    }
}

void SkillInfo::ClearChangesMask()
{
    Base::ClearChangesMask(SkillLineID);
    Base::ClearChangesMask(SkillStep);
    Base::ClearChangesMask(SkillRank);
    Base::ClearChangesMask(SkillStartingRank);
    Base::ClearChangesMask(SkillMaxRank);
    Base::ClearChangesMask(SkillTempBonus);
    Base::ClearChangesMask(SkillPermBonus);
    _changesMask.ResetAll();
}

void RestInfo::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << uint32(Threshold);
    data << uint8(StateID);
}

void RestInfo::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 3);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << uint32(Threshold);
        }
        if (changesMask[2])
        {
            data << uint8(StateID);
        }
    }
}

void RestInfo::ClearChangesMask()
{
    Base::ClearChangesMask(Threshold);
    Base::ClearChangesMask(StateID);
    _changesMask.ResetAll();
}

void PVPInfo::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << uint32(WeeklyPlayed);
    data << uint32(WeeklyWon);
    data << uint32(SeasonPlayed);
    data << uint32(SeasonWon);
    data << uint32(Rating);
    data << uint32(WeeklyBestRating);
    data << uint32(SeasonBestRating);
    data << uint32(PvpTierID);
    data << uint32(WeeklyBestWinPvpTierID);
    data << uint32(Field_28);
    data << uint32(Field_2C);
    data.WriteBit(Disqualified);
    data.FlushBits();
}

void PVPInfo::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 13);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBit(Disqualified);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            data << uint32(WeeklyPlayed);
        }
        if (changesMask[3])
        {
            data << uint32(WeeklyWon);
        }
        if (changesMask[4])
        {
            data << uint32(SeasonPlayed);
        }
        if (changesMask[5])
        {
            data << uint32(SeasonWon);
        }
        if (changesMask[6])
        {
            data << uint32(Rating);
        }
        if (changesMask[7])
        {
            data << uint32(WeeklyBestRating);
        }
        if (changesMask[8])
        {
            data << uint32(SeasonBestRating);
        }
        if (changesMask[9])
        {
            data << uint32(PvpTierID);
        }
        if (changesMask[10])
        {
            data << uint32(WeeklyBestWinPvpTierID);
        }
        if (changesMask[11])
        {
            data << uint32(Field_28);
        }
        if (changesMask[12])
        {
            data << uint32(Field_2C);
        }
    }
    data.FlushBits();
}

void PVPInfo::ClearChangesMask()
{
    Base::ClearChangesMask(Disqualified);
    Base::ClearChangesMask(WeeklyPlayed);
    Base::ClearChangesMask(WeeklyWon);
    Base::ClearChangesMask(SeasonPlayed);
    Base::ClearChangesMask(SeasonWon);
    Base::ClearChangesMask(Rating);
    Base::ClearChangesMask(WeeklyBestRating);
    Base::ClearChangesMask(SeasonBestRating);
    Base::ClearChangesMask(PvpTierID);
    Base::ClearChangesMask(WeeklyBestWinPvpTierID);
    Base::ClearChangesMask(Field_28);
    Base::ClearChangesMask(Field_2C);
    _changesMask.ResetAll();
}

void CharacterRestriction::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(Field_0);
    data << int32(Field_4);
    data << int32(Field_8);
    data.WriteBits(Type, 5);
    data.FlushBits();
}

void CharacterRestriction::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    data << int32(Field_0);
    data << int32(Field_4);
    data << int32(Field_8);
    data.WriteBits(Type, 5);
    data.FlushBits();
}

bool CharacterRestriction::operator==(CharacterRestriction const& right) const
{
    return Field_0 == right.Field_0
        && Field_4 == right.Field_4
        && Field_8 == right.Field_8
        && Type == right.Type;
}

void SpellPctModByLabel::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(ModIndex);
    data << float(ModifierValue);
    data << int32(LabelID);
}

void SpellPctModByLabel::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    data << int32(ModIndex);
    data << float(ModifierValue);
    data << int32(LabelID);
}

bool SpellPctModByLabel::operator==(SpellPctModByLabel const& right) const
{
    return ModIndex == right.ModIndex
        && ModifierValue == right.ModifierValue
        && LabelID == right.LabelID;
}

void SpellFlatModByLabel::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int32(ModIndex);
    data << int32(ModifierValue);
    data << int32(LabelID);
}

void SpellFlatModByLabel::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    data << int32(ModIndex);
    data << int32(ModifierValue);
    data << int32(LabelID);
}

bool SpellFlatModByLabel::operator==(SpellFlatModByLabel const& right) const
{
    return ModIndex == right.ModIndex
        && ModifierValue == right.ModifierValue
        && LabelID == right.LabelID;
}

void Research::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << int16(ResearchProjectID);
}

void Research::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    data << int16(ResearchProjectID);
}

bool Research::operator==(Research const& right) const
{
    return ResearchProjectID == right.ResearchProjectID;
}

void GlyphInfo::WriteCreate(ByteBuffer& data, Player const* owner, Player const* receiver) const
{
    data << uint32(GlyphSlot);
    data << uint32(Glyph);
}

void GlyphInfo::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Player const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 3);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << uint32(GlyphSlot);
        }
        if (changesMask[2])
        {
            data << uint32(Glyph);
        }
    }
}

void GlyphInfo::ClearChangesMask()
{
    Base::ClearChangesMask(GlyphSlot);
    Base::ClearChangesMask(Glyph);
    _changesMask.ResetAll();
}

void ActivePlayerData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Player const* owner, Player const* receiver) const
{
    for (std::size_t i = 0; i < 129; ++i)
    {
        data << InvSlots[i];
    }
    data << FarsightObject;
    data << ComboTarget;
    data << uint32(KnownTitles.size());
    data << uint64(Coinage);
    data << int32(XP);
    data << int32(NextLevelXP);
    data << int32(TrialXP);
    Skill->WriteCreate(data, owner, receiver);
    data << int32(CharacterPoints);
    data << int32(MaxTalentTiers);
    data << uint32(TrackCreatureMask);
    for (std::size_t i = 0; i < 2; ++i)
    {
        data << uint32(TrackResourceMask[i]);
    }
    data << float(MainhandExpertise);
    data << float(OffhandExpertise);
    data << float(RangedExpertise);
    data << float(CombatRatingExpertise);
    data << float(BlockPercentage);
    data << float(DodgePercentage);
    data << float(DodgePercentageFromAttribute);
    data << float(ParryPercentage);
    data << float(ParryPercentageFromAttribute);
    data << float(CritPercentage);
    data << float(RangedCritPercentage);
    data << float(OffhandCritPercentage);
    for (std::size_t i = 0; i < 7; ++i)
    {
        data << float(SpellCritPercentage[i]);
        data << int32(ModDamageDonePos[i]);
        data << int32(ModDamageDoneNeg[i]);
        data << float(ModDamageDonePercent[i]);
    }
    data << int32(ShieldBlock);
    data << float(Mastery);
    data << float(Speed);
    data << float(Avoidance);
    data << float(Sturdiness);
    data << float(Unk340_3);
    data << int32(Versatility);
    data << float(VersatilityBonus);
    data << float(PvpPowerDamage);
    data << float(PvpPowerHealing);
    for (std::size_t i = 0; i < 240; ++i)
    {
        data << uint64(ExploredZones[i]);
    }
    for (std::size_t i = 0; i < 2; ++i)
    {
        RestInfo[i].WriteCreate(data, owner, receiver);
    }
    data << int32(ModHealingDonePos);
    data << float(ModHealingPercent);
    data << float(ModHealingDonePercent);
    data << float(ModPeriodicHealingDonePercent);
    for (std::size_t i = 0; i < 3; ++i)
    {
        data << float(WeaponDmgMultipliers[i]);
        data << float(WeaponAtkSpeedMultipliers[i]);
    }
    data << float(ModSpellPowerPercent);
    data << float(ModResiliencePercent);
    data << float(OverrideSpellPowerByAPPercent);
    data << float(OverrideAPBySpellPowerPercent);
    data << int32(ModTargetResistance);
    data << int32(ModTargetPhysicalResistance);
    data << uint32(LocalFlags);
    data << uint8(GrantableLevels);
    data << uint8(MultiActionBars);
    data << uint8(LifetimeMaxRank);
    data << uint8(NumRespecs);
    data << int32(AmmoID);
    data << uint32(PvpMedals);
    for (std::size_t i = 0; i < 12; ++i)
    {
        data << uint32(BuybackPrice[i]);
        data << int64(BuybackTimestamp[i]);
    }
    data << uint16(TodayHonorableKills);
    data << uint16(TodayDishonorableKills);
    data << uint16(YesterdayHonorableKills);
    data << uint16(YesterdayDishonorableKills);
    data << uint16(LastWeekHonorableKills);
    data << uint16(LastWeekDishonorableKills);
    data << uint16(ThisWeekHonorableKills);
    data << uint16(ThisWeekDishonorableKills);
    data << uint32(ThisWeekContribution);
    data << uint32(LifetimeHonorableKills);
    data << uint32(LifetimeDishonorableKills);
    data << uint32(YesterdayContribution);
    data << uint32(LastWeekContribution);
    data << uint32(LastWeekRank);
    data << int32(WatchedFactionIndex);
    for (std::size_t i = 0; i < 32; ++i)
    {
        data << int32(CombatRatings[i]);
    }
    data << int32(MaxLevel);
    data << int32(ScalingPlayerLevelDelta);
    data << int32(MaxCreatureScalingLevel);
    for (std::size_t i = 0; i < 4; ++i)
    {
        data << uint32(NoReagentCostMask[i]);
    }
    data << int32(PetSpellPower);
    for (std::size_t i = 0; i < 2; ++i)
    {
        data << int32(ProfessionSkillLine[i]);
    }
    data << float(UiHitModifier);
    data << float(UiSpellHitModifier);
    data << int32(HomeRealmTimeOffset);
    data << float(ModPetHaste);
    data << uint8(LocalRegenFlags);
    data << uint8(AuraVision);
    data << uint8(NumBackpackSlots);
    data << int32(OverrideSpellsID);
    data << int32(LfgBonusFactionID);
    data << uint16(LootSpecID);
    data << uint32(OverrideZonePVPType);
    for (std::size_t i = 0; i < 4; ++i)
    {
        data << uint32(BagSlotFlags[i]);
    }
    for (std::size_t i = 0; i < 7; ++i)
    {
        data << uint32(BankBagSlotFlags[i]);
    }
    for (std::size_t i = 0; i < 875; ++i)
    {
        data << uint64(QuestCompleted[i]);
    }
    data << int32(Honor);
    data << int32(HonorNextLevel);
    data << int32(PvpTierMaxFromWins);
    data << int32(PvpLastWeeksTierMaxFromWins);
    data << uint8(NumBankSlots);
    data << uint32(ResearchSites.size());
    data << uint32(ResearchSiteProgress.size());
    data << uint32(DailyQuestsCompleted.size());
    data << uint32(AvailableQuestLineXQuestIDs.size());
    data << uint32(Unk254.size());
    data << uint32(Heirlooms.size());
    data << uint32(HeirloomFlags.size());
    data << uint32(Toys.size());
    data << uint32(Transmog.size());
    data << uint32(ConditionalTransmog.size());
    data << uint32(SelfResSpells.size());
    data << uint32(CharacterRestrictions.size());
    data << uint32(SpellPctModByLabel.size());
    data << uint32(SpellFlatModByLabel.size());
    for (std::size_t i = 0; i < 1; ++i)
    {
        data << uint32(Research[i].size());
        for (std::size_t j = 0; j < Research[i].size(); ++j)
        {
            Research[i][j].WriteCreate(data, owner, receiver);
        }
    }
    data << int32(TransportServerTime);
    for (std::size_t i = 0; i < 6; ++i)
    {
        GlyphInfos[i].WriteCreate(data, owner, receiver);
    }
    data << uint8(GlyphsEnabled);
    for (std::size_t i = 0; i < KnownTitles.size(); ++i)
    {
        data << uint64(KnownTitles[i]);
    }
    for (std::size_t i = 0; i < ResearchSites.size(); ++i)
    {
        data << uint32(ResearchSites[i]);
    }
    for (std::size_t i = 0; i < ResearchSiteProgress.size(); ++i)
    {
        data << uint32(ResearchSiteProgress[i]);
    }
    for (std::size_t i = 0; i < DailyQuestsCompleted.size(); ++i)
    {
        data << int32(DailyQuestsCompleted[i]);
    }
    for (std::size_t i = 0; i < AvailableQuestLineXQuestIDs.size(); ++i)
    {
        data << int32(AvailableQuestLineXQuestIDs[i]);
    }
    for (std::size_t i = 0; i < Unk254.size(); ++i)
    {
        data << int32(Unk254[i]);
    }
    for (std::size_t i = 0; i < Heirlooms.size(); ++i)
    {
        data << int32(Heirlooms[i]);
    }
    for (std::size_t i = 0; i < HeirloomFlags.size(); ++i)
    {
        data << uint32(HeirloomFlags[i]);
    }
    for (std::size_t i = 0; i < Toys.size(); ++i)
    {
        data << int32(Toys[i]);
    }
    for (std::size_t i = 0; i < Transmog.size(); ++i)
    {
        data << uint32(Transmog[i]);
    }
    for (std::size_t i = 0; i < ConditionalTransmog.size(); ++i)
    {
        data << int32(ConditionalTransmog[i]);
    }
    for (std::size_t i = 0; i < SelfResSpells.size(); ++i)
    {
        data << int32(SelfResSpells[i]);
    }
    for (std::size_t i = 0; i < SpellPctModByLabel.size(); ++i)
    {
        SpellPctModByLabel[i].WriteCreate(data, owner, receiver);
    }
    for (std::size_t i = 0; i < SpellFlatModByLabel.size(); ++i)
    {
        SpellFlatModByLabel[i].WriteCreate(data, owner, receiver);
    }
    for (std::size_t i = 0; i < 6; ++i)
    {
        PvpInfo[i].WriteCreate(data, owner, receiver);
    }
    data.FlushBits();
    data.WriteBit(InsertItemsLeftToRight);
    for (std::size_t i = 0; i < CharacterRestrictions.size(); ++i)
    {
        CharacterRestrictions[i].WriteCreate(data, owner, receiver);
    }
    data.FlushBits();
}

void ActivePlayerData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Player const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void ActivePlayerData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, Player const* owner, Player const* receiver) const
{
    for (std::size_t i = 0; i < 1; ++i)
        data << uint32(changesMask.GetBlocksMask(i));
    data.WriteBits(changesMask.GetBlocksMask(1), 15);
    for (std::size_t i = 0; i < 47; ++i)
        if (changesMask.GetBlock(i))
            data.WriteBits(changesMask.GetBlock(i), 32);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBit(InsertItemsLeftToRight);
        }
        if (changesMask[2])
        {
            if (!ignoreNestedChangesMask)
                KnownTitles.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(KnownTitles.size(), data);
        }
        if (changesMask[3])
        {
            if (!ignoreNestedChangesMask)
                ResearchSites.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(ResearchSites.size(), data);
        }
        if (changesMask[4])
        {
            if (!ignoreNestedChangesMask)
                ResearchSiteProgress.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(ResearchSiteProgress.size(), data);
        }
        if (changesMask[5])
        {
            if (!ignoreNestedChangesMask)
                DailyQuestsCompleted.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(DailyQuestsCompleted.size(), data);
        }
        if (changesMask[6])
        {
            if (!ignoreNestedChangesMask)
                AvailableQuestLineXQuestIDs.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(AvailableQuestLineXQuestIDs.size(), data);
        }
        if (changesMask[7])
        {
            if (!ignoreNestedChangesMask)
                Unk254.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(Unk254.size(), data);
        }
        if (changesMask[8])
        {
            if (!ignoreNestedChangesMask)
                Heirlooms.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(Heirlooms.size(), data);
        }
        if (changesMask[9])
        {
            if (!ignoreNestedChangesMask)
                HeirloomFlags.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(HeirloomFlags.size(), data);
        }
        if (changesMask[10])
        {
            if (!ignoreNestedChangesMask)
                Toys.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(Toys.size(), data);
        }
        if (changesMask[11])
        {
            if (!ignoreNestedChangesMask)
                Transmog.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(Transmog.size(), data);
        }
        if (changesMask[12])
        {
            if (!ignoreNestedChangesMask)
                ConditionalTransmog.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(ConditionalTransmog.size(), data);
        }
        if (changesMask[13])
        {
            if (!ignoreNestedChangesMask)
                SelfResSpells.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(SelfResSpells.size(), data);
        }
        if (changesMask[14])
        {
            if (!ignoreNestedChangesMask)
                CharacterRestrictions.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(CharacterRestrictions.size(), data);
        }
        if (changesMask[15])
        {
            if (!ignoreNestedChangesMask)
                SpellPctModByLabel.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(SpellPctModByLabel.size(), data);
        }
        if (changesMask[16])
        {
            if (!ignoreNestedChangesMask)
                SpellFlatModByLabel.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(SpellFlatModByLabel.size(), data);
        }
    }
    if (changesMask[17])
    {
        for (std::size_t i = 0; i < 1; ++i)
        {
            if (changesMask[18 + i])
            {
                if (!ignoreNestedChangesMask)
                    Research[i].WriteUpdateMask(data);
                else
                    WriteCompleteDynamicFieldUpdateMask(Research[i].size(), data);
                for (std::size_t j = 0; j < Research[i].size(); ++j)
                {
                    if (Research[i].HasChanged(j) || ignoreNestedChangesMask)
                    {
                        Research[i][j].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                    }
                }
            }
        }
    }
    data.FlushBits();
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            for (std::size_t i = 0; i < KnownTitles.size(); ++i)
            {
                if (KnownTitles.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << uint64(KnownTitles[i]);
                }
            }
        }
        if (changesMask[3])
        {
            for (std::size_t i = 0; i < ResearchSites.size(); ++i)
            {
                if (ResearchSites.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << uint32(ResearchSites[i]);
                }
            }
        }
        if (changesMask[4])
        {
            for (std::size_t i = 0; i < ResearchSiteProgress.size(); ++i)
            {
                if (ResearchSiteProgress.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << uint32(ResearchSiteProgress[i]);
                }
            }
        }
        if (changesMask[5])
        {
            for (std::size_t i = 0; i < DailyQuestsCompleted.size(); ++i)
            {
                if (DailyQuestsCompleted.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(DailyQuestsCompleted[i]);
                }
            }
        }
        if (changesMask[6])
        {
            for (std::size_t i = 0; i < AvailableQuestLineXQuestIDs.size(); ++i)
            {
                if (AvailableQuestLineXQuestIDs.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(AvailableQuestLineXQuestIDs[i]);
                }
            }
        }
        if (changesMask[7])
        {
            for (std::size_t i = 0; i < Unk254.size(); ++i)
            {
                if (Unk254.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(Unk254[i]);
                }
            }
        }
        if (changesMask[8])
        {
            for (std::size_t i = 0; i < Heirlooms.size(); ++i)
            {
                if (Heirlooms.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(Heirlooms[i]);
                }
            }
        }
        if (changesMask[9])
        {
            for (std::size_t i = 0; i < HeirloomFlags.size(); ++i)
            {
                if (HeirloomFlags.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << uint32(HeirloomFlags[i]);
                }
            }
        }
        if (changesMask[10])
        {
            for (std::size_t i = 0; i < Toys.size(); ++i)
            {
                if (Toys.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(Toys[i]);
                }
            }
        }
        if (changesMask[11])
        {
            for (std::size_t i = 0; i < Transmog.size(); ++i)
            {
                if (Transmog.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << uint32(Transmog[i]);
                }
            }
        }
        if (changesMask[12])
        {
            for (std::size_t i = 0; i < ConditionalTransmog.size(); ++i)
            {
                if (ConditionalTransmog.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(ConditionalTransmog[i]);
                }
            }
        }
        if (changesMask[13])
        {
            for (std::size_t i = 0; i < SelfResSpells.size(); ++i)
            {
                if (SelfResSpells.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(SelfResSpells[i]);
                }
            }
        }
        if (changesMask[15])
        {
            for (std::size_t i = 0; i < SpellPctModByLabel.size(); ++i)
            {
                if (SpellPctModByLabel.HasChanged(i) || ignoreNestedChangesMask)
                {
                    SpellPctModByLabel[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[16])
        {
            for (std::size_t i = 0; i < SpellFlatModByLabel.size(); ++i)
            {
                if (SpellFlatModByLabel.HasChanged(i) || ignoreNestedChangesMask)
                {
                    SpellFlatModByLabel[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[14])
        {
            for (std::size_t i = 0; i < CharacterRestrictions.size(); ++i)
            {
                if (CharacterRestrictions.HasChanged(i) || ignoreNestedChangesMask)
                {
                    CharacterRestrictions[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[19])
        {
            data << FarsightObject;
        }
        if (changesMask[20])
        {
            data << ComboTarget;
        }
        if (changesMask[21])
        {
            data << uint64(Coinage);
        }
        if (changesMask[22])
        {
            data << int32(XP);
        }
        if (changesMask[23])
        {
            data << int32(NextLevelXP);
        }
        if (changesMask[24])
        {
            data << int32(TrialXP);
        }
        if (changesMask[25])
        {
            Skill->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
        if (changesMask[26])
        {
            data << int32(CharacterPoints);
        }
        if (changesMask[27])
        {
            data << int32(MaxTalentTiers);
        }
        if (changesMask[28])
        {
            data << uint32(TrackCreatureMask);
        }
        if (changesMask[29])
        {
            data << float(MainhandExpertise);
        }
        if (changesMask[30])
        {
            data << float(OffhandExpertise);
        }
        if (changesMask[31])
        {
            data << float(RangedExpertise);
        }
        if (changesMask[32])
        {
            data << float(CombatRatingExpertise);
        }
        if (changesMask[33])
        {
            data << float(BlockPercentage);
        }
    }
    if (changesMask[34])
    {
        if (changesMask[35])
        {
            data << float(DodgePercentage);
        }
        if (changesMask[36])
        {
            data << float(DodgePercentageFromAttribute);
        }
        if (changesMask[37])
        {
            data << float(ParryPercentage);
        }
        if (changesMask[38])
        {
            data << float(ParryPercentageFromAttribute);
        }
        if (changesMask[39])
        {
            data << float(CritPercentage);
        }
        if (changesMask[40])
        {
            data << float(RangedCritPercentage);
        }
        if (changesMask[41])
        {
            data << float(OffhandCritPercentage);
        }
        if (changesMask[42])
        {
            data << int32(ShieldBlock);
        }
        if (changesMask[43])
        {
            data << float(Mastery);
        }
        if (changesMask[44])
        {
            data << float(Speed);
        }
        if (changesMask[45])
        {
            data << float(Avoidance);
        }
        if (changesMask[46])
        {
            data << float(Sturdiness);
        }
        if (changesMask[47])
        {
            data << float(Unk340_3);
        }
        if (changesMask[48])
        {
            data << int32(Versatility);
        }
        if (changesMask[49])
        {
            data << float(VersatilityBonus);
        }
        if (changesMask[50])
        {
            data << float(PvpPowerDamage);
        }
        if (changesMask[51])
        {
            data << float(PvpPowerHealing);
        }
        if (changesMask[52])
        {
            data << int32(ModHealingDonePos);
        }
        if (changesMask[53])
        {
            data << float(ModHealingPercent);
        }
        if (changesMask[54])
        {
            data << float(ModHealingDonePercent);
        }
        if (changesMask[55])
        {
            data << float(ModPeriodicHealingDonePercent);
        }
        if (changesMask[56])
        {
            data << float(ModSpellPowerPercent);
        }
        if (changesMask[57])
        {
            data << float(ModResiliencePercent);
        }
        if (changesMask[58])
        {
            data << float(OverrideSpellPowerByAPPercent);
        }
        if (changesMask[59])
        {
            data << float(OverrideAPBySpellPowerPercent);
        }
        if (changesMask[60])
        {
            data << int32(ModTargetResistance);
        }
        if (changesMask[61])
        {
            data << int32(ModTargetPhysicalResistance);
        }
        if (changesMask[62])
        {
            data << uint32(LocalFlags);
        }
        if (changesMask[63])
        {
            data << uint8(GrantableLevels);
        }
        if (changesMask[64])
        {
            data << uint8(MultiActionBars);
        }
        if (changesMask[65])
        {
            data << uint8(LifetimeMaxRank);
        }
    }
    if (changesMask[66])
    {
        if (changesMask[67])
        {
            data << uint8(NumRespecs);
        }
        if (changesMask[68])
        {
            data << int32(AmmoID);
        }
        if (changesMask[69])
        {
            data << uint32(PvpMedals);
        }
        if (changesMask[70])
        {
            data << uint16(TodayHonorableKills);
        }
        if (changesMask[71])
        {
            data << uint16(TodayDishonorableKills);
        }
        if (changesMask[72])
        {
            data << uint16(YesterdayHonorableKills);
        }
        if (changesMask[73])
        {
            data << uint16(YesterdayDishonorableKills);
        }
        if (changesMask[74])
        {
            data << uint16(LastWeekHonorableKills);
        }
        if (changesMask[75])
        {
            data << uint16(LastWeekDishonorableKills);
        }
        if (changesMask[76])
        {
            data << uint16(ThisWeekHonorableKills);
        }
        if (changesMask[77])
        {
            data << uint16(ThisWeekDishonorableKills);
        }
        if (changesMask[78])
        {
            data << uint32(ThisWeekContribution);
        }
        if (changesMask[79])
        {
            data << uint32(LifetimeHonorableKills);
        }
        if (changesMask[80])
        {
            data << uint32(LifetimeDishonorableKills);
        }
        if (changesMask[81])
        {
            data << uint32(YesterdayContribution);
        }
        if (changesMask[82])
        {
            data << uint32(LastWeekContribution);
        }
        if (changesMask[83])
        {
            data << uint32(LastWeekRank);
        }
        if (changesMask[84])
        {
            data << int32(WatchedFactionIndex);
        }
        if (changesMask[85])
        {
            data << int32(MaxLevel);
        }
        if (changesMask[86])
        {
            data << int32(ScalingPlayerLevelDelta);
        }
        if (changesMask[87])
        {
            data << int32(MaxCreatureScalingLevel);
        }
        if (changesMask[88])
        {
            data << int32(PetSpellPower);
        }
        if (changesMask[89])
        {
            data << float(UiHitModifier);
        }
        if (changesMask[90])
        {
            data << float(UiSpellHitModifier);
        }
        if (changesMask[91])
        {
            data << int32(HomeRealmTimeOffset);
        }
        if (changesMask[92])
        {
            data << float(ModPetHaste);
        }
        if (changesMask[93])
        {
            data << uint8(LocalRegenFlags);
        }
        if (changesMask[94])
        {
            data << uint8(AuraVision);
        }
        if (changesMask[95])
        {
            data << uint8(NumBackpackSlots);
        }
        if (changesMask[96])
        {
            data << int32(OverrideSpellsID);
        }
        if (changesMask[97])
        {
            data << int32(LfgBonusFactionID);
        }
    }
    if (changesMask[98])
    {
        if (changesMask[99])
        {
            data << uint16(LootSpecID);
        }
        if (changesMask[100])
        {
            data << uint32(OverrideZonePVPType);
        }
        if (changesMask[101])
        {
            data << int32(Honor);
        }
        if (changesMask[102])
        {
            data << int32(HonorNextLevel);
        }
        if (changesMask[103])
        {
            data << int32(PvpTierMaxFromWins);
        }
        if (changesMask[104])
        {
            data << int32(PvpLastWeeksTierMaxFromWins);
        }
        if (changesMask[105])
        {
            data << uint8(NumBankSlots);
        }
        if (changesMask[106])
        {
            data << int32(TransportServerTime);
        }
        if (changesMask[107])
        {
            data << uint8(GlyphsEnabled);
        }
    }
    if (changesMask[108])
    {
        for (std::size_t i = 0; i < 129; ++i)
        {
            if (changesMask[109 + i])
            {
                data << InvSlots[i];
            }
        }
    }
    if (changesMask[238])
    {
        for (std::size_t i = 0; i < 2; ++i)
        {
            if (changesMask[239 + i])
            {
                data << uint32(TrackResourceMask[i]);
            }
        }
    }
    if (changesMask[241])
    {
        for (std::size_t i = 0; i < 7; ++i)
        {
            if (changesMask[242 + i])
            {
                data << float(SpellCritPercentage[i]);
            }
            if (changesMask[249 + i])
            {
                data << int32(ModDamageDonePos[i]);
            }
            if (changesMask[256 + i])
            {
                data << int32(ModDamageDoneNeg[i]);
            }
            if (changesMask[263 + i])
            {
                data << float(ModDamageDonePercent[i]);
            }
        }
    }
    if (changesMask[270])
    {
        for (std::size_t i = 0; i < 240; ++i)
        {
            if (changesMask[271 + i])
            {
                data << uint64(ExploredZones[i]);
            }
        }
    }
    if (changesMask[511])
    {
        for (std::size_t i = 0; i < 2; ++i)
        {
            if (changesMask[512 + i])
            {
                RestInfo[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
            }
        }
    }
    if (changesMask[514])
    {
        for (std::size_t i = 0; i < 3; ++i)
        {
            if (changesMask[515 + i])
            {
                data << float(WeaponDmgMultipliers[i]);
            }
            if (changesMask[518 + i])
            {
                data << float(WeaponAtkSpeedMultipliers[i]);
            }
        }
    }
    if (changesMask[521])
    {
        for (std::size_t i = 0; i < 12; ++i)
        {
            if (changesMask[522 + i])
            {
                data << uint32(BuybackPrice[i]);
            }
            if (changesMask[534 + i])
            {
                data << int64(BuybackTimestamp[i]);
            }
        }
    }
    if (changesMask[546])
    {
        for (std::size_t i = 0; i < 32; ++i)
        {
            if (changesMask[547 + i])
            {
                data << int32(CombatRatings[i]);
            }
        }
    }
    if (changesMask[586])
    {
        for (std::size_t i = 0; i < 4; ++i)
        {
            if (changesMask[587 + i])
            {
                data << uint32(NoReagentCostMask[i]);
            }
        }
    }
    if (changesMask[591])
    {
        for (std::size_t i = 0; i < 2; ++i)
        {
            if (changesMask[592 + i])
            {
                data << int32(ProfessionSkillLine[i]);
            }
        }
    }
    if (changesMask[594])
    {
        for (std::size_t i = 0; i < 4; ++i)
        {
            if (changesMask[595 + i])
            {
                data << uint32(BagSlotFlags[i]);
            }
        }
    }
    if (changesMask[599])
    {
        for (std::size_t i = 0; i < 7; ++i)
        {
            if (changesMask[600 + i])
            {
                data << uint32(BankBagSlotFlags[i]);
            }
        }
    }
    if (changesMask[607])
    {
        for (std::size_t i = 0; i < 875; ++i)
        {
            if (changesMask[608 + i])
            {
                data << uint64(QuestCompleted[i]);
            }
        }
    }
    if (changesMask[1483])
    {
        for (std::size_t i = 0; i < 6; ++i)
        {
            if (changesMask[1484 + i])
            {
                GlyphInfos[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
            }
        }
    }
    if (changesMask[579])
    {
        for (std::size_t i = 0; i < 6; ++i)
        {
            if (changesMask[580 + i])
            {
                PvpInfo[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
            }
        }
    }
    data.FlushBits();
}

void ActivePlayerData::ClearChangesMask()
{
    Base::ClearChangesMask(InsertItemsLeftToRight);
    Base::ClearChangesMask(Research);
    Base::ClearChangesMask(KnownTitles);
    Base::ClearChangesMask(ResearchSites);
    Base::ClearChangesMask(ResearchSiteProgress);
    Base::ClearChangesMask(DailyQuestsCompleted);
    Base::ClearChangesMask(AvailableQuestLineXQuestIDs);
    Base::ClearChangesMask(Unk254);
    Base::ClearChangesMask(Heirlooms);
    Base::ClearChangesMask(HeirloomFlags);
    Base::ClearChangesMask(Toys);
    Base::ClearChangesMask(Transmog);
    Base::ClearChangesMask(ConditionalTransmog);
    Base::ClearChangesMask(SelfResSpells);
    Base::ClearChangesMask(SpellPctModByLabel);
    Base::ClearChangesMask(SpellFlatModByLabel);
    Base::ClearChangesMask(CharacterRestrictions);
    Base::ClearChangesMask(FarsightObject);
    Base::ClearChangesMask(ComboTarget);
    Base::ClearChangesMask(Coinage);
    Base::ClearChangesMask(XP);
    Base::ClearChangesMask(NextLevelXP);
    Base::ClearChangesMask(TrialXP);
    Base::ClearChangesMask(Skill);
    Base::ClearChangesMask(CharacterPoints);
    Base::ClearChangesMask(MaxTalentTiers);
    Base::ClearChangesMask(TrackCreatureMask);
    Base::ClearChangesMask(MainhandExpertise);
    Base::ClearChangesMask(OffhandExpertise);
    Base::ClearChangesMask(RangedExpertise);
    Base::ClearChangesMask(CombatRatingExpertise);
    Base::ClearChangesMask(BlockPercentage);
    Base::ClearChangesMask(DodgePercentage);
    Base::ClearChangesMask(DodgePercentageFromAttribute);
    Base::ClearChangesMask(ParryPercentage);
    Base::ClearChangesMask(ParryPercentageFromAttribute);
    Base::ClearChangesMask(CritPercentage);
    Base::ClearChangesMask(RangedCritPercentage);
    Base::ClearChangesMask(OffhandCritPercentage);
    Base::ClearChangesMask(ShieldBlock);
    Base::ClearChangesMask(Mastery);
    Base::ClearChangesMask(Speed);
    Base::ClearChangesMask(Avoidance);
    Base::ClearChangesMask(Sturdiness);
    Base::ClearChangesMask(Unk340_3);
    Base::ClearChangesMask(Versatility);
    Base::ClearChangesMask(VersatilityBonus);
    Base::ClearChangesMask(PvpPowerDamage);
    Base::ClearChangesMask(PvpPowerHealing);
    Base::ClearChangesMask(ModHealingDonePos);
    Base::ClearChangesMask(ModHealingPercent);
    Base::ClearChangesMask(ModHealingDonePercent);
    Base::ClearChangesMask(ModPeriodicHealingDonePercent);
    Base::ClearChangesMask(ModSpellPowerPercent);
    Base::ClearChangesMask(ModResiliencePercent);
    Base::ClearChangesMask(OverrideSpellPowerByAPPercent);
    Base::ClearChangesMask(OverrideAPBySpellPowerPercent);
    Base::ClearChangesMask(ModTargetResistance);
    Base::ClearChangesMask(ModTargetPhysicalResistance);
    Base::ClearChangesMask(LocalFlags);
    Base::ClearChangesMask(GrantableLevels);
    Base::ClearChangesMask(MultiActionBars);
    Base::ClearChangesMask(LifetimeMaxRank);
    Base::ClearChangesMask(NumRespecs);
    Base::ClearChangesMask(AmmoID);
    Base::ClearChangesMask(PvpMedals);
    Base::ClearChangesMask(TodayHonorableKills);
    Base::ClearChangesMask(TodayDishonorableKills);
    Base::ClearChangesMask(YesterdayHonorableKills);
    Base::ClearChangesMask(YesterdayDishonorableKills);
    Base::ClearChangesMask(LastWeekHonorableKills);
    Base::ClearChangesMask(LastWeekDishonorableKills);
    Base::ClearChangesMask(ThisWeekHonorableKills);
    Base::ClearChangesMask(ThisWeekDishonorableKills);
    Base::ClearChangesMask(ThisWeekContribution);
    Base::ClearChangesMask(LifetimeHonorableKills);
    Base::ClearChangesMask(LifetimeDishonorableKills);
    Base::ClearChangesMask(YesterdayContribution);
    Base::ClearChangesMask(LastWeekContribution);
    Base::ClearChangesMask(LastWeekRank);
    Base::ClearChangesMask(WatchedFactionIndex);
    Base::ClearChangesMask(MaxLevel);
    Base::ClearChangesMask(ScalingPlayerLevelDelta);
    Base::ClearChangesMask(MaxCreatureScalingLevel);
    Base::ClearChangesMask(PetSpellPower);
    Base::ClearChangesMask(UiHitModifier);
    Base::ClearChangesMask(UiSpellHitModifier);
    Base::ClearChangesMask(HomeRealmTimeOffset);
    Base::ClearChangesMask(ModPetHaste);
    Base::ClearChangesMask(LocalRegenFlags);
    Base::ClearChangesMask(AuraVision);
    Base::ClearChangesMask(NumBackpackSlots);
    Base::ClearChangesMask(OverrideSpellsID);
    Base::ClearChangesMask(LfgBonusFactionID);
    Base::ClearChangesMask(LootSpecID);
    Base::ClearChangesMask(OverrideZonePVPType);
    Base::ClearChangesMask(Honor);
    Base::ClearChangesMask(HonorNextLevel);
    Base::ClearChangesMask(PvpTierMaxFromWins);
    Base::ClearChangesMask(PvpLastWeeksTierMaxFromWins);
    Base::ClearChangesMask(NumBankSlots);
    Base::ClearChangesMask(TransportServerTime);
    Base::ClearChangesMask(GlyphsEnabled);
    Base::ClearChangesMask(InvSlots);
    Base::ClearChangesMask(TrackResourceMask);
    Base::ClearChangesMask(SpellCritPercentage);
    Base::ClearChangesMask(ModDamageDonePos);
    Base::ClearChangesMask(ModDamageDoneNeg);
    Base::ClearChangesMask(ModDamageDonePercent);
    Base::ClearChangesMask(ExploredZones);
    Base::ClearChangesMask(RestInfo);
    Base::ClearChangesMask(WeaponDmgMultipliers);
    Base::ClearChangesMask(WeaponAtkSpeedMultipliers);
    Base::ClearChangesMask(BuybackPrice);
    Base::ClearChangesMask(BuybackTimestamp);
    Base::ClearChangesMask(CombatRatings);
    Base::ClearChangesMask(PvpInfo);
    Base::ClearChangesMask(NoReagentCostMask);
    Base::ClearChangesMask(ProfessionSkillLine);
    Base::ClearChangesMask(BagSlotFlags);
    Base::ClearChangesMask(BankBagSlotFlags);
    Base::ClearChangesMask(QuestCompleted);
    Base::ClearChangesMask(GlyphInfos);
    _changesMask.ResetAll();
}

void GameObjectData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, GameObject const* owner, Player const* receiver) const
{
    data << int32(DisplayID);
    data << uint32(SpellVisualID);
    data << uint32(StateSpellVisualID);
    data << uint32(SpawnTrackingStateAnimID);
    data << uint32(SpawnTrackingStateAnimKitID);
    data << uint32(StateWorldEffectIDs->size());
    for (std::size_t i = 0; i < StateWorldEffectIDs->size(); ++i)
    {
        data << uint32((*StateWorldEffectIDs)[i]);
    }
    data << CreatedBy;
    data << GuildGUID;
    data << uint32(ViewerDependentValue<FlagsTag>::GetValue(this, owner, receiver));
    data << float(ParentRotation->x);
    data << float(ParentRotation->y);
    data << float(ParentRotation->z);
    data << float(ParentRotation->w);
    data << int32(FactionTemplate);
    data << int32(Level);
    data << int8(State);
    data << int8(TypeID);
    data << uint8(PercentHealth);
    data << uint32(ArtKit);
    data << uint32(EnableDoodadSets.size());
    data << uint32(CustomParam);
    for (std::size_t i = 0; i < EnableDoodadSets.size(); ++i)
    {
        data << int32(EnableDoodadSets[i]);
    }
}

void GameObjectData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, GameObject const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void GameObjectData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, GameObject const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlock(0), 19);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBits(StateWorldEffectIDs->size(), 32);
            for (std::size_t i = 0; i < StateWorldEffectIDs->size(); ++i)
            {
                data << uint32((*StateWorldEffectIDs)[i]);
            }
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            if (!ignoreNestedChangesMask)
                EnableDoodadSets.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(EnableDoodadSets.size(), data);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            for (std::size_t i = 0; i < EnableDoodadSets.size(); ++i)
            {
                if (EnableDoodadSets.HasChanged(i) || ignoreNestedChangesMask)
                {
                    data << int32(EnableDoodadSets[i]);
                }
            }
        }
        if (changesMask[3])
        {
            data << int32(DisplayID);
        }
        if (changesMask[4])
        {
            data << uint32(SpellVisualID);
        }
        if (changesMask[5])
        {
            data << uint32(StateSpellVisualID);
        }
        if (changesMask[6])
        {
            data << uint32(SpawnTrackingStateAnimID);
        }
        if (changesMask[7])
        {
            data << uint32(SpawnTrackingStateAnimKitID);
        }
        if (changesMask[8])
        {
            data << CreatedBy;
        }
        if (changesMask[9])
        {
            data << GuildGUID;
        }
        if (changesMask[10])
        {
            data << uint32(ViewerDependentValue<FlagsTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[11])
        {
            data << float(ParentRotation->x);
            data << float(ParentRotation->y);
            data << float(ParentRotation->z);
            data << float(ParentRotation->w);
        }
        if (changesMask[12])
        {
            data << int32(FactionTemplate);
        }
        if (changesMask[13])
        {
            data << int32(Level);
        }
        if (changesMask[14])
        {
            data << int8(State);
        }
        if (changesMask[15])
        {
            data << int8(TypeID);
        }
        if (changesMask[16])
        {
            data << uint8(PercentHealth);
        }
        if (changesMask[17])
        {
            data << uint32(ArtKit);
        }
        if (changesMask[18])
        {
            data << uint32(CustomParam);
        }
    }
}

void GameObjectData::ClearChangesMask()
{
    Base::ClearChangesMask(StateWorldEffectIDs);
    Base::ClearChangesMask(EnableDoodadSets);
    Base::ClearChangesMask(DisplayID);
    Base::ClearChangesMask(SpellVisualID);
    Base::ClearChangesMask(StateSpellVisualID);
    Base::ClearChangesMask(SpawnTrackingStateAnimID);
    Base::ClearChangesMask(SpawnTrackingStateAnimKitID);
    Base::ClearChangesMask(CreatedBy);
    Base::ClearChangesMask(GuildGUID);
    Base::ClearChangesMask(Flags);
    Base::ClearChangesMask(ParentRotation);
    Base::ClearChangesMask(FactionTemplate);
    Base::ClearChangesMask(Level);
    Base::ClearChangesMask(State);
    Base::ClearChangesMask(TypeID);
    Base::ClearChangesMask(PercentHealth);
    Base::ClearChangesMask(ArtKit);
    Base::ClearChangesMask(CustomParam);
    _changesMask.ResetAll();
}

void DynamicObjectData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, DynamicObject const* owner, Player const* receiver) const
{
    data << Caster;
    data << uint8(Type);
    data << int32(SpellXSpellVisualID);
    data << int32(SpellID);
    data << float(Radius);
    data << uint32(CastTime);
}

void DynamicObjectData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, DynamicObject const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void DynamicObjectData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, DynamicObject const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlock(0), 7);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << Caster;
        }
        if (changesMask[2])
        {
            data << uint8(Type);
        }
        if (changesMask[3])
        {
            data << int32(SpellXSpellVisualID);
        }
        if (changesMask[4])
        {
            data << int32(SpellID);
        }
        if (changesMask[5])
        {
            data << float(Radius);
        }
        if (changesMask[6])
        {
            data << uint32(CastTime);
        }
    }
}

void DynamicObjectData::ClearChangesMask()
{
    Base::ClearChangesMask(Caster);
    Base::ClearChangesMask(Type);
    Base::ClearChangesMask(SpellXSpellVisualID);
    Base::ClearChangesMask(SpellID);
    Base::ClearChangesMask(Radius);
    Base::ClearChangesMask(CastTime);
    _changesMask.ResetAll();
}

void CorpseData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Corpse const* owner, Player const* receiver) const
{
    data << uint32(DynamicFlags);
    data << Owner;
    data << PartyGUID;
    data << GuildGUID;
    data << uint32(DisplayID);
    for (std::size_t i = 0; i < 19; ++i)
    {
        data << uint32(Items[i]);
    }
    data << uint8(RaceID);
    data << uint8(Sex);
    data << uint8(Class);
    data << uint32(Customizations.size());
    data << uint32(Flags);
    data << int32(FactionTemplate);
    for (std::size_t i = 0; i < Customizations.size(); ++i)
    {
        Customizations[i].WriteCreate(data, owner, receiver);
    }
}

void CorpseData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Corpse const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void CorpseData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, Corpse const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlocksMask(0), 1);
    for (std::size_t i = 0; i < 1; ++i)
        if (changesMask.GetBlock(i))
            data.WriteBits(changesMask.GetBlock(i), 32);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            if (!ignoreNestedChangesMask)
                Customizations.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(Customizations.size(), data);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            for (std::size_t i = 0; i < Customizations.size(); ++i)
            {
                if (Customizations.HasChanged(i) || ignoreNestedChangesMask)
                {
                    Customizations[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[2])
        {
            data << uint32(DynamicFlags);
        }
        if (changesMask[3])
        {
            data << Owner;
        }
        if (changesMask[4])
        {
            data << PartyGUID;
        }
        if (changesMask[5])
        {
            data << GuildGUID;
        }
        if (changesMask[6])
        {
            data << uint32(DisplayID);
        }
        if (changesMask[7])
        {
            data << uint8(RaceID);
        }
        if (changesMask[8])
        {
            data << uint8(Sex);
        }
        if (changesMask[9])
        {
            data << uint8(Class);
        }
        if (changesMask[10])
        {
            data << uint32(Flags);
        }
        if (changesMask[11])
        {
            data << int32(FactionTemplate);
        }
    }
    if (changesMask[12])
    {
        for (std::size_t i = 0; i < 19; ++i)
        {
            if (changesMask[13 + i])
            {
                data << uint32(Items[i]);
            }
        }
    }
}

void CorpseData::ClearChangesMask()
{
    Base::ClearChangesMask(Customizations);
    Base::ClearChangesMask(DynamicFlags);
    Base::ClearChangesMask(Owner);
    Base::ClearChangesMask(PartyGUID);
    Base::ClearChangesMask(GuildGUID);
    Base::ClearChangesMask(DisplayID);
    Base::ClearChangesMask(RaceID);
    Base::ClearChangesMask(Sex);
    Base::ClearChangesMask(Class);
    Base::ClearChangesMask(Flags);
    Base::ClearChangesMask(FactionTemplate);
    Base::ClearChangesMask(Items);
    _changesMask.ResetAll();
}

void ScaleCurve::WriteCreate(ByteBuffer& data, AreaTrigger const* owner, Player const* receiver) const
{
    data << uint32(StartTimeOffset);
    for (std::size_t i = 0; i < 2; ++i)
    {
        data << Points[i];
    }
    data << uint32(ParameterCurve);
    data.WriteBit(OverrideActive);
    data.FlushBits();
}

void ScaleCurve::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, AreaTrigger const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 7);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBit(OverrideActive);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            data << uint32(StartTimeOffset);
        }
        if (changesMask[3])
        {
            data << uint32(ParameterCurve);
        }
    }
    if (changesMask[4])
    {
        for (std::size_t i = 0; i < 2; ++i)
        {
            if (changesMask[5 + i])
            {
                data << Points[i];
            }
        }
    }
    data.FlushBits();
}

void ScaleCurve::ClearChangesMask()
{
    Base::ClearChangesMask(OverrideActive);
    Base::ClearChangesMask(StartTimeOffset);
    Base::ClearChangesMask(ParameterCurve);
    Base::ClearChangesMask(Points);
    _changesMask.ResetAll();
}

void VisualAnim::WriteCreate(ByteBuffer& data, AreaTrigger const* owner, Player const* receiver) const
{
    data << uint32(AnimationDataID);
    data << uint32(AnimKitID);
    data << uint32(AnimProgress);
    data.WriteBit(Field_C);
    data.FlushBits();
}

void VisualAnim::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, AreaTrigger const* owner, Player const* receiver) const
{
    Mask changesMask = _changesMask;
    if (ignoreChangesMask)
        changesMask.SetAll();

    data.WriteBits(changesMask.GetBlock(0), 5);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBit(Field_C);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            data << uint32(AnimationDataID);
        }
        if (changesMask[3])
        {
            data << uint32(AnimKitID);
        }
        if (changesMask[4])
        {
            data << uint32(AnimProgress);
        }
    }
    data.FlushBits();
}

void VisualAnim::ClearChangesMask()
{
    Base::ClearChangesMask(Field_C);
    Base::ClearChangesMask(AnimationDataID);
    Base::ClearChangesMask(AnimKitID);
    Base::ClearChangesMask(AnimProgress);
    _changesMask.ResetAll();
}

void AreaTriggerData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, AreaTrigger const* owner, Player const* receiver) const
{
    OverrideScaleCurve->WriteCreate(data, owner, receiver);
    data << Caster;
    data << uint32(Duration);
    data << uint32(TimeToTarget);
    data << uint32(TimeToTargetScale);
    data << uint32(TimeToTargetExtraScale);
    data << int32(SpellID);
    data << int32(SpellForVisuals);
    data << int32(SpellXSpellVisualID);
    data << float(BoundsRadius2D);
    data << uint32(DecalPropertiesID);
    data << CreatingEffectGUID;
    data << Field_80;
    ExtraScaleCurve->WriteCreate(data, owner, receiver);
    VisualAnim->WriteCreate(data, owner, receiver);
}

void AreaTriggerData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, AreaTrigger const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void AreaTriggerData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, AreaTrigger const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlock(0), 16);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            OverrideScaleCurve->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
        if (changesMask[3])
        {
            data << Caster;
        }
        if (changesMask[4])
        {
            data << uint32(Duration);
        }
        if (changesMask[5])
        {
            data << uint32(TimeToTarget);
        }
        if (changesMask[6])
        {
            data << uint32(TimeToTargetScale);
        }
        if (changesMask[7])
        {
            data << uint32(TimeToTargetExtraScale);
        }
        if (changesMask[8])
        {
            data << int32(SpellID);
        }
        if (changesMask[9])
        {
            data << int32(SpellForVisuals);
        }
        if (changesMask[10])
        {
            data << int32(SpellXSpellVisualID);
        }
        if (changesMask[11])
        {
            data << float(BoundsRadius2D);
        }
        if (changesMask[12])
        {
            data << uint32(DecalPropertiesID);
        }
        if (changesMask[13])
        {
            data << CreatingEffectGUID;
        }
        if (changesMask[14])
        {
            data << Field_80;
        }
        if (changesMask[2])
        {
            ExtraScaleCurve->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
        if (changesMask[15])
        {
            VisualAnim->WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
        }
    }
}

void AreaTriggerData::ClearChangesMask()
{
    Base::ClearChangesMask(OverrideScaleCurve);
    Base::ClearChangesMask(ExtraScaleCurve);
    Base::ClearChangesMask(Caster);
    Base::ClearChangesMask(Duration);
    Base::ClearChangesMask(TimeToTarget);
    Base::ClearChangesMask(TimeToTargetScale);
    Base::ClearChangesMask(TimeToTargetExtraScale);
    Base::ClearChangesMask(SpellID);
    Base::ClearChangesMask(SpellForVisuals);
    Base::ClearChangesMask(SpellXSpellVisualID);
    Base::ClearChangesMask(BoundsRadius2D);
    Base::ClearChangesMask(DecalPropertiesID);
    Base::ClearChangesMask(CreatingEffectGUID);
    Base::ClearChangesMask(Field_80);
    Base::ClearChangesMask(VisualAnim);
    _changesMask.ResetAll();
}

void SceneObjectData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Object const* owner, Player const* receiver) const
{
    data << int32(ScriptPackageID);
    data << uint32(RndSeedVal);
    data << CreatedBy;
    data << uint32(SceneType);
}

void SceneObjectData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Object const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void SceneObjectData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, Object const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlock(0), 5);

    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data << int32(ScriptPackageID);
        }
        if (changesMask[2])
        {
            data << uint32(RndSeedVal);
        }
        if (changesMask[3])
        {
            data << CreatedBy;
        }
        if (changesMask[4])
        {
            data << uint32(SceneType);
        }
    }
}

void SceneObjectData::ClearChangesMask()
{
    Base::ClearChangesMask(ScriptPackageID);
    Base::ClearChangesMask(RndSeedVal);
    Base::ClearChangesMask(CreatedBy);
    Base::ClearChangesMask(SceneType);
    _changesMask.ResetAll();
}

void ConversationLine::WriteCreate(ByteBuffer& data, Conversation const* owner, Player const* receiver) const
{
    data << int32(ConversationLineID);
    data << uint32(ViewerDependentValue<StartTimeTag>::GetValue(this, owner, receiver));
    data << int32(UiCameraID);
    data << uint8(ActorIndex);
    data << uint8(Flags);
}

void ConversationLine::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Conversation const* owner, Player const* receiver) const
{
    data << int32(ConversationLineID);
    data << uint32(ViewerDependentValue<StartTimeTag>::GetValue(this, owner, receiver));
    data << int32(UiCameraID);
    data << uint8(ActorIndex);
    data << uint8(Flags);
}

bool ConversationLine::operator==(ConversationLine const& right) const
{
    return ConversationLineID == right.ConversationLineID
        && StartTime == right.StartTime
        && UiCameraID == right.UiCameraID
        && ActorIndex == right.ActorIndex
        && Flags == right.Flags;
}

void ConversationActor::WriteCreate(ByteBuffer& data, Conversation const* owner, Player const* receiver) const
{
    data.WriteBits(Type, 1);
    data << int32(Id);
    data << ActorGUID;
    data << uint32(CreatureID);
    data << uint32(CreatureDisplayInfoID);
    data.FlushBits();
}

void ConversationActor::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, Conversation const* owner, Player const* receiver) const
{
    data.WriteBits(Type, 1);
    data << int32(Id);
    data << ActorGUID;
    data << uint32(CreatureID);
    data << uint32(CreatureDisplayInfoID);
    data.FlushBits();
}

bool ConversationActor::operator==(ConversationActor const& right) const
{
    return Type == right.Type
        && Id == right.Id
        && ActorGUID == right.ActorGUID
        && CreatureID == right.CreatureID
        && CreatureDisplayInfoID == right.CreatureDisplayInfoID;
}

void ConversationData::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Conversation const* owner, Player const* receiver) const
{
    data << uint32(Lines->size());
    data << int32(ViewerDependentValue<LastLineEndTimeTag>::GetValue(this, owner, receiver));
    for (std::size_t i = 0; i < Lines->size(); ++i)
    {
        (*Lines)[i].WriteCreate(data, owner, receiver);
    }
    data << uint32(Progress);
    data << uint32(Actors.size());
    for (std::size_t i = 0; i < Actors.size(); ++i)
    {
        Actors[i].WriteCreate(data, owner, receiver);
    }
}

void ConversationData::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, Conversation const* owner, Player const* receiver) const
{
    WriteUpdate(data, _changesMask, false, owner, receiver);
}

void ConversationData::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, Conversation const* owner, Player const* receiver) const
{
    data.WriteBits(changesMask.GetBlock(0), 5);

    if (changesMask[0])
    {
        if (changesMask[1])
        {
            data.WriteBits(Lines->size(), 32);
            for (std::size_t i = 0; i < Lines->size(); ++i)
            {
                (*Lines)[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
            }
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            if (!ignoreNestedChangesMask)
                Actors.WriteUpdateMask(data);
            else
                WriteCompleteDynamicFieldUpdateMask(Actors.size(), data);
        }
    }
    data.FlushBits();
    if (changesMask[0])
    {
        if (changesMask[2])
        {
            for (std::size_t i = 0; i < Actors.size(); ++i)
            {
                if (Actors.HasChanged(i) || ignoreNestedChangesMask)
                {
                    Actors[i].WriteUpdate(data, ignoreNestedChangesMask, owner, receiver);
                }
            }
        }
        if (changesMask[3])
        {
            data << int32(ViewerDependentValue<LastLineEndTimeTag>::GetValue(this, owner, receiver));
        }
        if (changesMask[4])
        {
            data << uint32(Progress);
        }
    }
}

void ConversationData::ClearChangesMask()
{
    Base::ClearChangesMask(Lines);
    Base::ClearChangesMask(Actors);
    Base::ClearChangesMask(LastLineEndTime);
    Base::ClearChangesMask(Progress);
    _changesMask.ResetAll();
}

}

#if TRINITY_COMPILER == TRINITY_COMPILER_GNU
#pragma GCC diagnostic pop
#else
#pragma warning(pop)
#endif
